---
title: 摘樱桃
date: 2022-10-05 21:51:55
permalink: /pages/297a1e/
categories:
  - algorithm
  - leetcode
tags:
  - 
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
---


## 题目

一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：

- 0 表示这个格子是空的，所以你可以穿过它。
- 1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
- -1 表示这个格子里有荆棘，挡着你的路。

你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：

- 从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
- 当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
- 当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
- 如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。

示例 1:

    输入: grid =
    [[0, 1, -1],
     [1, 0, -1],
     [1, 1,  1]]
    输出: 5
    解释： 
    玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
    在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
    接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
    在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。
说明:

- grid 是一个 N * N 的二维数组，N的取值范围是1 <= N <= 50。
- 每一个 grid[i][j] 都是集合 {-1, 0, 1}其中的一个数。
- 可以保证起点 grid[0][0] 和终点 grid[N-1][N-1] 的值都不会是 -1。


## 思路

    //本题等价于两个人都是从[0,0]出发一直到右下角,两个人的樱桃总数的最大值是多少
    //尝试从左上角推至右下角,所以仰仗左上角的子结构的值时,容易越界,此时为dp数组的左面和上面各扩充一列和一行
    //副对角线上的坐标关系建议用手捣鼓两下就明白了了
    int n = grid.length;
    int[][][] dp = new int[n+1][n+1][2*n+1];
        

## 解法
```java

class Solution {
    public int cherryPickup(int[][] grid) {
        //本题等价于两个人都是从[0,0]出发一直到右下角,两个人的樱桃总数的最大值是多少
        //尝试从左上角推至右下角,所以仰仗左上角的子结构的值时,容易越界,此时为dp数组的左面和上面各扩充一列和一行
        //副对角线上的坐标关系建议用手捣鼓两下就明白了了
        int n = grid.length;
        int[][][] dp = new int[n+1][n+1][2*n+1];
        for(int i=0;i<=n;i++){
                for(int j=0;j<=n;j++){
                    for(int k=0;k<=2*n;k++){
                        dp[i][j][k] = Integer.MIN_VALUE;
                    }
                }
            }
        dp[1][1][2] = grid[0][0];
        //dp[i][j][k]由以下参数得到,也就是仰仗左上角的最优子结构
        /**
         * 1.右右:dp[i][j][k-1]
         * 2.右下:dp[i][j-1][k-1]
         * 3.下右:dp[i-1][j][k-1]
         * 4.下下:dp[i-1][j-1][k-1]
         */
        for(int k=3;k<2*n+1;k++){
            for(int i1=1;i1<=n;i1++){
                for(int i2=1;i2<=n;i2++){
                    int j1=k-i1;
                    int j2=k-i2;
                    if(j1<=0||j1>=n+1||j2<=0||j2>=n+1) continue;//越界
                    int A=grid[i1-1][j1-1];
                    int B=grid[i2-1][j2-1];
                    if(A==-1||B==-1) continue;//压根到不了
                    int a = dp[i1][i2][k-1];
                    int b = dp[i1][i2-1][k-1];
                    int c = dp[i1-1][i2][k-1];
                    int d = dp[i1-1][i2-1][k-1];
                    int t = Math.max(Math.max(a,b),Math.max(c,d))+A;
                    if(i1!=i2) t+=B;
                    dp[i1][i2][k] = t;
                }
            }
        }
        return dp[n][n][2*n]<0?0:dp[n][n][2*n];
    }
}
```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
