---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1734. 解码异或后的排列
---

## 题目

给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。

它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。

给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。



示例 1：

    输入：encoded = [3,1]
    输出：[1,2,3]
    解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
示例 2：

    输入：encoded = [6,5,4,6]
    输出：[2,4,1,5,3]


提示：

* 3 <= n < 10<sup>5</sup>
* n 是奇数。
* encoded.length == n - 1

## 思路

位运算

## 解法
```java
class Solution {
    public int[] decode(int[] encoded) {
        int num =0;
        int[] nums = new int[encoded.length+1];
        for(int i = 1;i<nums.length+1;i++){
            num^=i;
        }
        int count = 0;
        for(int j = 1;j<encoded.length;j+=2){
            count ^=encoded[j];
        }
        nums[0] = num^count;
        for(int i =1;i<encoded.length+1;i++){
            nums[i]= encoded[i-1]^nums[i-1]; 
        }
        return nums;
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
