---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1738. 找出第K大的异或坐标值
---

## 题目
给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。

矩阵中坐标 (a, b) 的 目标值 可以通过对所有元素 matrix[i][j] 执行异或运算得到，其中 i 和 j 满足 0 <= i <= a < m 且 0 <= j <= b < n（下标从 0 开始计数）。

请你找出 matrix 的所有坐标中第 k 大的目标值（k 的值从 1 开始计数）。



示例 1：

    输入：matrix = [[5,2],[1,6]], k = 1
    输出：7
    解释：坐标 (0,1) 的目标值是 5 XOR 2 = 7 ，为最大的目标值。
示例 2：

    输入：matrix = [[5,2],[1,6]], k = 2
    输出：5
    解释：坐标 (0,0) 的目标值是 5 = 5 ，为第 2 大的目标值。
示例 3：

    输入：matrix = [[5,2],[1,6]], k = 3
    输出：4
    解释：坐标 (1,0) 的目标值是 5 XOR 1 = 4 ，为第 3 大的目标值。
示例 4：

    输入：matrix = [[5,2],[1,6]], k = 4
    输出：0
    解释：坐标 (1,1) 的目标值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的目标值。


提示：

* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 1000
* 0 <= matrix[i][j] <= 10<sup>6</sup>
* 1 <= k <= m * n


## 思路

二维前缀和

## 解法
```java
class Solution {
    public int kthLargestValue(int[][] matrix, int k) {
        int m = matrix.length, n = matrix[0].length;
        int[][] xor = new int[m][n];
        xor[0][0] = matrix[0][0];
        for (int i = 1; i < m; i++) {
            xor[i][0] = xor[i - 1][0] ^ matrix[i][0];
        }
        for (int j = 1; j < n; j++) {
            xor[0][j] = xor[0][j - 1] ^ matrix[0][j];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                xor[i][j] = xor[i - 1][j] ^ xor[i][j - 1] ^ xor[i - 1][j - 1] ^ matrix[i][j];
            }
        }
        int[] flat = new int[n * m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                flat[i * n + j] = xor[i][j];
            }
        }
        Arrays.sort(flat);
        return flat[n * m - k];
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
