---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1866. 恰有K根木棍可以看到的排列数目
date: 2025-06-09 20:14:58
permalink: /pages/7b2b6c/
---

## 题目

有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。

* 例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。
给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。



示例 1：

    输入：n = 3, k = 2
    输出：3
    解释：[1,3,2], [2,3,1] 和 [2,1,3] 是仅有的能满足恰好 2 根木棍可以看到的排列。
    可以看到的木棍已经用粗体+斜体标识。
示例 2：

    输入：n = 5, k = 5
    输出：1
    解释：[1,2,3,4,5] 是唯一一种能满足全部 5 根木棍可以看到的排列。
    可以看到的木棍已经用粗体+斜体标识。
示例 3：

    输入：n = 20, k = 11
    输出：647427950
    解释：总共有 647427950 (mod 109 + 7) 种能满足恰好有 11 根木棍可以看到的排列。


提示：

* 1 <= n <= 1000
* 1 <= k <= n

## 思路

dp[i][j] 表示 i 根木棍，中能看到 j 个木棍得情况

## 解法
```java
class Solution {
public int rearrangeSticks(int n, int k) {
        // dp[i][j] 表示 i 根木棍，中能看到 j 个木棍得情况
        long[][] dp = new long[n+1][k+1];
        int mod = (int) 1e9 + 7;
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(k, i); j++) {
                // dp[i-1][j-1] 表示 最小得木棍放在第一个看得到的情况， 
                // dp[i-1][j] * (i-1) 表示 最小得木棍不放在第一个(一定看不到), 所以表示i-1根木棍看的到j得情况，然后插入最小木棍(除第一个位置)得情况
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] * (i-1)) % mod;
            }
        }
        return (int) dp[n][k];
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
