---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1914. 循环轮转矩阵
---

## 题目
给你一个大小为 m x n 的整数矩阵 grid​​​ ，其中 m 和 n 都是 偶数 ；另给你一个整数 k 。

矩阵由若干层组成，如下图所示，每种颜色代表一层：

![ringofgrid.png](..%2F..%2F..%2Fmedia%2Fpictures%2Fleetcode%2Fringofgrid.png)

矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下：

![explanation_grid.jpg](..%2F..%2F..%2Fmedia%2Fpictures%2Fleetcode%2Fexplanation_grid.jpg)
返回执行 k 次循环轮转操作后的矩阵。



示例 1：
![rod2.png](..%2F..%2F..%2Fmedia%2Fpictures%2Fleetcode%2Frod2.png)

    输入：grid = [[40,10],[30,20]], k = 1
    输出：[[10,20],[40,30]]
    解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。
示例 2：

![ringofgrid5.png](..%2F..%2F..%2Fmedia%2Fpictures%2Fleetcode%2Fringofgrid5.png)

![ringofgrid6.png](..%2F..%2F..%2Fmedia%2Fpictures%2Fleetcode%2Fringofgrid6.png)

![ringofgrid7.png](..%2F..%2F..%2Fmedia%2Fpictures%2Fleetcode%2Fringofgrid7.png)


    输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2
    输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]]
    解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。


提示：

* m == grid.length
* n == grid[i].length
* 2 <= m, n <= 50
* m 和 n 都是 偶数
* 1 <= grid[i][j] <= 5000
* 1 <= k <= 10<sup>9</sup>


## 思路

把每一圈的取出来旋转后更新

## 解法
```java
class Solution {
    public int[][] rotateGrid(int[][] grid, int k) {
        int m=grid.length,n=grid[0].length;
        for(int i=0;i<Math.min(m/2,n/2);i++){
            int[] arr=getArr(grid,i,m,n);
            arr=rotation(arr,k);
            update(grid,i,arr,m,n);
        }
        return grid;
    }
    public void update(int[][] grid,int layer,int[] arr,int m,int n){
        int index=0;
        for(int i=layer;i<m-layer;i++){
            grid[i][layer]=arr[index++];
        }
        for(int j=layer+1;j<n-layer;j++){
            grid[m-1-layer][j]=arr[index++];
        }
        for(int i=m-1-layer-1;i>=layer;i--){
            grid[i][n-1-layer]=arr[index++];
        }
        for(int j=n-1-layer-1;j>layer;j--){
            grid[layer][j]=arr[index++];
        }
    }
    public int[] rotation(int[] arr,int k){
        int n=arr.length;
        k%=n;
        int[] res=new int[arr.length];
        System.arraycopy(arr,0,res,k,arr.length-k);
        System.arraycopy(arr,arr.length-k,res,0,k);
        return res;
    }
    public int[] getArr(int[][] grid,int layer,int m,int n){
        List<Integer> lists=new ArrayList<>();
        for(int i=layer;i<m-layer;i++){
            lists.add(grid[i][layer]);
        }
        for(int j=layer+1;j<n-layer;j++){
            lists.add(grid[m-1-layer][j]);
        }
        for(int i=m-1-layer-1;i>=layer;i--){
            lists.add(grid[i][n-1-layer]);
        }
        for(int j=n-1-layer-1;j>layer;j--){
            lists.add(grid[layer][j]);
        }
        return lists.stream().mapToInt(e->e).toArray();
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
