---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1871. 跳跃游戏VII
date: 2025-06-09 20:14:58
permalink: /pages/cdaa82/
---

## 题目

给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 '0' 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处：

* i + minJump <= j <= min(i + maxJump, s.length - 1) 且
* s[j] == '0'.
如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。



示例 1：

    输入：s = "011010", minJump = 2, maxJump = 3
    输出：true
    解释：
    第一步，从下标 0 移动到下标 3 。
    第二步，从下标 3 移动到下标 5 。
示例 2：

    输入：s = "01101110", minJump = 2, maxJump = 3
    输出：false


提示：

* 2 <= s.length <= 10<sup>5</sup>
* s[i] 要么是 '0' ，要么是 '1'
* s[0] == '0'
* 1 <= minJump <= maxJump < s.length

## 思路

不回头维护更新dp数组。

## 解法
```java
class Solution {
    public boolean canReach(String s, int minJump, int maxJump) {
        boolean[] dp = new boolean[s.length()];
        dp[0] = true;
        int index = 0;
        for(int i=0;i<s.length();i++){
            if(dp[i]){
                for(int j=Math.max(index,i+minJump);j<=Math.min(i+maxJump,s.length()-1);j++){
                    if(s.charAt(j)=='0') dp[j] = true; 
                }
                index = Math.min(i+maxJump,s.length()-1);
            }
        }
        return dp[dp.length-1];
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
