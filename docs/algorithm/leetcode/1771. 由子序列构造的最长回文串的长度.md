---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1771. 由子序列构造的最长回文串的长度
---

## 题目

给你两个字符串 word1 和 word2 ，请你按下述方法构造一个字符串：

* 从 word1 中选出某个 非空 子序列 subsequence1 。
* 从 word2 中选出某个 非空 子序列 subsequence2 。
* 连接两个子序列 subsequence1 + subsequence2 ，得到字符串。
返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。

字符串 s 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。

回文串 是正着读和反着读结果一致的字符串。



示例 1：

    输入：word1 = "cacb", word2 = "cbba"
    输出：5
    解释：从 word1 中选出 "ab" ，从 word2 中选出 "cba" ，得到回文串 "abcba" 。
示例 2：

    输入：word1 = "ab", word2 = "ab"
    输出：3
    解释：从 word1 中选出 "ab" ，从 word2 中选出 "a" ，得到回文串 "aba" 。
示例 3：

    输入：word1 = "aa", word2 = "bb"
    输出：0
    解释：无法按题面所述方法构造回文串，所以返回 0 。


提示：

* 1 <= word1.length, word2.length <= 1000
* word1 和 word2 由小写英文字母组成

## 思路

简单的区间dp

## 解法
```java
class Solution {
    public int longestPalindrome(String word1, String word2) {
        String word = word1 + word2;
        int n1 = word1.length(), n2 = word2.length(), n = n1 + n2, res = 0;
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < n-i; j++) {
                dp[j][j+i] = Math.max(dp[j+1][j+i], dp[j][j+i-1]);
                if (word.charAt(j) != word.charAt(j+i)) continue;
                dp[j][j+i] = Math.max((i == 1 ? 0 : dp[j+1][j+i-1]) + 2, dp[j][j+i]);
                if (j < n1 && j+i >= n1) res = Math.max(res, dp[j][j+i]);
            }
        }
        return res == 1 ? 0 : res;
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
