---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1955. 统计特殊子序列的数目
---

## 题目

特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。

* 比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。
* 相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。
给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。

一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。



示例 1：

    输入：nums = [0,1,2,2]
    输出：3
    解释：特殊子序列为 [0,1,2,2]，[0,1,2,2] 和 [0,1,2,2] 。

示例 2：

    输入：nums = [2,2,0,0]
    输出：0
    解释：数组 [2,2,0,0] 中没有特殊子序列。

示例 3：

    输入：nums = [0,1,2,0,1,2]
    输出：7
    解释：特殊子序列包括：
    - [0,1,2,0,1,2]
    - [0,1,2,0,1,2]
    - [0,1,2,0,1,2]
    - [0,1,2,0,1,2]
    - [0,1,2,0,1,2]
    - [0,1,2,0,1,2]
    - [0,1,2,0,1,2]


提示：

* 1 <= nums.length <= 10<sup>5</sup>
* 0 <= nums[i] <= 2

## 思路

dp

## 解法
```java
class Solution {
    public int countSpecialSubsequences(int[] nums) {
        int len = nums.length, mod = (int) 1e9 + 7;
        long[] dp = {0,0,0};
        for (int i = 1; i <= len; i++) {
            if (nums[i-1] == 0) {
                dp[0] = (dp[0]*2 + 1) % mod;
            }
            if (nums[i-1] == 1 && dp[0] > 0) {
                dp[1] = (dp[1]*2 + dp[0]) % mod;
            }
            if (nums[i-1] == 2 && dp[1] > 0) {
                dp[2] = (dp[2]*2 + dp[1]) % mod;
            }
        }
        return (int) dp[2];
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
