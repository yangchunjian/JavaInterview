---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1911. 最大交替子序列和
---

## 题目

一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

* 比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。

一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。



示例 1：

    输入：nums = [4,2,5,3]
    输出：7
    解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
示例 2：
    
    输入：nums = [5,6,7,8]
    输出：8
    解释：最优子序列为 [8] ，交替和为 8 。
示例 3：
    
    输入：nums = [6,2,1,2,4,5]
    输出：10
    解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。


提示：

* 1 <= nums.length <= 10<sup>5</sup>
* 1 <= nums[i] <= 10<sup>5</sup>

## 思路

先卖后买的卖股票



## 解法
```java
class Solution {
    public long maxAlternatingSum(int[] nums) {
        int length = nums.length;
        long[] dp = new long[2];
//        dp[0]表示持有股票  dp[1]表示不持有股票
//        可以理解为初始我们身上就有一张价值nums[0]的股票
//        dp[0]表示这张股票我们没有卖出去，还放在身上，所以资金为0
//        dp[1]表示这张股票卖了出去，所以我们身上有这张股票卖出去的钱
        dp[1] = nums[0];
        dp[0] = 0;
        for (int i = 1; i < length; i++) {
//            持有股票有两种可能，前一天也持有，也可能前一天不持有，二者取最大值
//            前一天不持有的话，今天持有，就需要付出今天股票的价格来购买今天的股票
            dp[0] = Math.max(dp[0], dp[1] - nums[i]);
//            同理
            dp[1] = Math.max(dp[1], dp[0] + nums[i]);
        }
//        最后一定是不持有股票，将股票卖出去后身上所剩下的钱最多
        return dp[1];
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
