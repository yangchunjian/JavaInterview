---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1975. 最大方阵和
---

## 题目

给你一个 n x n 的整数方阵 matrix 。你可以执行以下操作 任意次 ：

* 选择 matrix 中 相邻 两个元素，并将它们都 乘以 -1 。
如果两个元素有 公共边 ，那么它们就是 相邻 的。

你的目的是 最大化 方阵元素的和。请你在执行以上操作之后，返回方阵的 最大 和。



示例 1：
![pc79-q2ex1.png](../../../media/pictures/leetcode/pc79-q2ex1.png)

    输入：matrix = [[1,-1],[-1,1]]
    输出：4
    解释：我们可以执行以下操作使和等于 4 ：
    - 将第一行的 2 个元素乘以 -1 。
    - 将第一列的 2 个元素乘以 -1 。
  
示例 2：
![pc79-q2ex2.png](../../../media/pictures/leetcode/pc79-q2ex2.png)

    输入：matrix = [[1,2,3],[-1,-2,-3],[1,2,3]]
    输出：16
    解释：我们可以执行以下操作使和等于 16 ：
    - 将第二行的最后 2 个元素乘以 -1 。


提示：

* n == matrix.length == matrix[i].length
* 2 <= n <= 250
* -105 <= matrix[i][j] <= 10<sup>5</sup>

## 思路


奇数个负号，最后剩下一个负号，将负号移动到最小绝对值元素即可。

## 解法
```java
class Solution {
public long maxMatrixSum(int[][] matrix) {
        int negtiveCount = 0;
        long sum = 0;
        int absMinValue = Integer.MAX_VALUE;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] <= 0) {
                    negtiveCount++;
                }
                absMinValue = Math.min(absMinValue, Math.abs(matrix[i][j]));
                sum += Math.abs(matrix[i][j]);
            }
        }
        if (negtiveCount % 2 == 1) {
            return sum - absMinValue - absMinValue;
        }
        return sum;
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
