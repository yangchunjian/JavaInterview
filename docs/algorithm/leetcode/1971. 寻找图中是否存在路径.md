---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1971. 寻找图中是否存在路径
---

## 题目

有一个具有 n 个顶点的 双向 图，其中每个顶点标记从 0 到 n - 1（包含 0 和 n - 1）。图中的边用一个二维整数数组 edges 表示，其中 edges[i] = [ui, vi] 表示顶点 ui 和顶点 vi 之间的双向边。 每个顶点对由 最多一条 边连接，并且没有顶点存在与自身相连的边。

请你确定是否存在从顶点 source 开始，到顶点 destination 结束的 有效路径 。

给你数组 edges 和整数 n、source 和 destination，如果从 source 到 destination 存在 有效路径 ，则返回 true，否则返回 false 。



示例 1：
![validpath-ex1.png](../../../media/pictures/leetcode/validpath-ex1.png)

输入：n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2
输出：true
解释：存在由顶点 0 到顶点 2 的路径:
- 0 → 1 → 2
- 0 → 2
  
示例 2：

![validpath-ex2.png](../../../media/pictures/leetcode/validpath-ex2.png)
输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5
输出：false
解释：不存在由顶点 0 到顶点 5 的路径.


提示：

* 1 <= n <= 2 * 10<sup>5</sup>
* 0 <= edges.length <= 2 * 10<sup>5</sup>
* edges[i].length == 2
* 0 <= ui, vi <= n - 1
* ui != vi
* 0 <= source, destination <= n - 1
* 不存在重复边
* 不存在指向顶点自身的边

## 思路

广度搜索

## 解法
```java
class Solution {
public boolean validPath(int n, int[][] edges, int source, int destination) {
    ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
    for(int i = 0; i < n; i++){
        graph.add(new ArrayList<>());
    }
    for(int[] d : edges){
        int x = d[0], y = d[1];
        graph.get(x).add(y);
        graph.get(y).add(x);
    }
    boolean[] visit = new boolean[n];
    return dfs(graph, source, destination, visit);
}
public boolean dfs(ArrayList<ArrayList<Integer>> graph, int source, int destination, boolean[] visit){
    if(source == destination){
        return true;
    }
    visit[source] = true;
    for(int x : graph.get(source)){
        if(!visit[x]){
            if(dfs(graph, x, destination, visit)){
                return true;
            }
        }
    }
    return false;
}}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
