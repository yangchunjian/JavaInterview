---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1851. 包含每个查询的最小区间
date: 2025-06-09 20:14:58
permalink: /pages/f39c5c/
---

## 题目

给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。

再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。

以数组形式返回对应查询的所有答案。



示例 1：

    输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
    输出：[3,3,1,4]
    解释：查询处理如下：
    - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。
    - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。
    - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。
    - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。
  
示例 2：

    输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
    输出：[2,-1,4,6]
    解释：查询处理如下：
    - Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。
    - Query = 19：不存在包含 19 的区间，答案为 -1 。
    - Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。
    - Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。


提示：

* 1 <= intervals.length <= 10<sup>5</sup>
* 1 <= queries.length <= 10<sup>5</sup>
* intervals[i].length == 2
* 1 <= lefti <= righti <= 10<sup>7</sup>
* 1 <= queries[j] <= 10<sup>7</sup>

## 思路

优先级队列。

## 解法
```java
class Solution {
    
    public int[] minInterval(int[][] intervals, int[] queries) {
        int []res=new int[queries.length];
        int [][]s=new int [queries.length][2];
        for(int i=0;i<queries.length;i++){
            s[i][0]=queries[i];
            s[i][1]=i;
        }
        Arrays.sort(s,(w1,w2)->w1[0]-w2[0]);//查询从小到大排序
        PriorityQueue<int[]> heap=new PriorityQueue<>
                ((w1,w2)->(w1[1]-w1[0])-(w2[1]-w2[0]));//优先级队列，区间长度递增
        Arrays.sort(intervals,(w1,w2)->w1[0]-w2[0]);//区间起始位置从小到大排序
        //区间加入优先级队列
        //遍历查询
        int index=0;
        for(int i=0;i<queries.length;i++){
            while(index<intervals.length&&intervals[index][0]<=s[i][0]){//满足当前查询的区间都放入优先级队列
                heap.offer(intervals[index]);
                index++;
            }
            while(!heap.isEmpty()&&heap.peek()[1]<s[i][0]){
                heap.poll();//弹
            }
            if(!heap.isEmpty())
                res[s[i][1]]=heap.peek()[1]-heap.peek()[0]+1;
            else
                res[s[i][1]]=-1;
        }
        return res;
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
