---
categories: 
  - algorithm
  - leetcode
tags: 
  - Java
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: null
title: 1959. K次调整数组大小浪费的最小总空间
---

## 题目

你正在设计一个动态数组。给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 i 时刻数组中的元素数目。除此以外，你还有一个整数 k ，表示你可以 调整 数组大小的 最多 次数（每次都可以调整成 任意 大小）。

t 时刻数组的大小 sizet 必须大于等于 nums[t] ，因为数组需要有足够的空间容纳所有元素。t 时刻 浪费的空间 为 sizet - nums[t] ，总 浪费空间为满足 0 <= t < nums.length 的每一个时刻 t 浪费的空间 之和 。

在调整数组大小不超过 k 次的前提下，请你返回 最小总浪费空间 。

注意：数组最开始时可以为 任意大小 ，且 不计入 调整大小的操作次数。



示例 1：

    输入：nums = [10,20], k = 0
    输出：10
    解释：size = [20,20].
    我们可以让数组初始大小为 20 。
    总浪费空间为 (20 - 10) + (20 - 20) = 10 。
示例 2：

    输入：nums = [10,20,30], k = 1
    输出：10
    解释：size = [20,20,30].
    我们可以让数组初始大小为 20 ，然后时刻 2 调整大小为 30 。
    总浪费空间为 (20 - 10) + (20 - 20) + (30 - 30) = 10 。
示例 3：

    输入：nums = [10,20,15,30,20], k = 2
    输出：15
    解释：size = [10,20,20,30,30].
    我们可以让数组初始大小为 10 ，时刻 1 调整大小为 20 ，时刻 3 调整大小为 30 。
    总浪费空间为 (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15 。


提示：

* 1 <= nums.length <= 200
* 1 <= nums[i] <= 106
* 0 <= k <= nums.length - 1


## 思路

dp+预处理

## 解法
```java
class Solution {
    public int minSpaceWastedKResizing(int[] nums, int k) {
		int n = nums.length;
		int[][] cnt = new int[n][n];
		for (int i = 0; i < n; i++) {
			int sm = 0, mx = 0;
			for (int j = i; j < n; j++) {
				sm += nums[j];
				mx = Math.max(mx, nums[j]);
				cnt[i][j] = mx * (j - i + 1) - sm;
			}
		}
		int[][] dp = new int[n + 1][k + 1];
		for (int[] d : dp)
			Arrays.fill(d, Integer.MAX_VALUE / 2);
		dp[0][0] = 0;
		for (int i = 0; i < n; i++) {
			dp[i + 1][0] = cnt[0][i];
			for (int x = 0; x < k; x++)
				for (int j = i; j >= 0; j--)
					dp[i + 1][x + 1] = Math.min(dp[i + 1][x + 1], dp[j][x] + cnt[j][i]);
		}
		return dp[n][k];
	}
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
