---
categories: 
  - algorithm
  - leetcode
tags: 
  - null
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
feed: 
  enable: true
description: 887. 鸡蛋掉落
title: 鸡蛋掉落
date: 2024-09-16 23:05:55
permalink: /pages/b05d25/
---

## 题目

给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。

已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。

每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。

请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？


示例 1：

    输入：k = 1, n = 2
    输出：2
    解释：
    鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。
    否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。
    如果它没碎，那么肯定能得出 f = 2 。
    因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。
示例 2：

    输入：k = 2, n = 6
    输出：3
示例 3：

    输入：k = 3, n = 14
    输出：4


提示：

* 1 <= k <= 100
* 1 <= n <= 10<sup>4</sup>

## 思路

二维背包代码

## 解法
```java
class Solution {
    /**
     01背包问题
     */
    public int superEggDrop(int k, int n) {
        if(n==1){
            return 1;
        }
        //背包：鸡蛋数（k个）； 物品：操作数（n个）；价值：确定楼层
        int[][] dp = new int[k+1][n+1];

        // 有人问了，为什么不是鸡蛋作为物品，操作数作为背包？
        // 背包问题往往物品与价值有正相关关系。
        // 鸡蛋有k个，但实际不一定全都用上，限制一定的最小操作数，鸡蛋增加，确定楼层（价值）不一定增加
        // 而取一定的鸡蛋，操作数每增加1，确定楼层(价值)就会一定增加
        int count=0;

        // 先遍历物品，再遍历背包
        for(;dp[k][count]<n;){ // 遍历物品，这里直到价值为n就结束
            count++;
            for (int i = k; i >=1; i--) { // 遍历背包，二维数组可以正序或倒叙
                //当前价值 = 鸡蛋碎了的价值 + 鸡蛋没碎的价值 + 确定当前层的价值1
                dp[i][count] = dp[i-1][count-1]+dp[i][count-1]+1;
            }
        }

        return count;
    }
}

```

## 总结

- 分析出几种情况，然后分别对各个情况实现 
