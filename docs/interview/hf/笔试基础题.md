---
title: 笔试基础题
date: 2022-10-11 12:41:49
permalink: /pages/9a8187/
categories:
  - interview
  - hf
tags:
  - 
author: 
  name: JavaInterview.cn
  link: https://JavaInterview.cn
titleTag: Java
---

## 解答

以下答案仅做参考，不保证正确性。

### 逻辑题(建议全做，时间控制在十分钟左右)

1. 注重对孩子的自然教育，让孩子亲身感受大自然的神奇与美妙，可促进孩子释放天性，激发自身潜 能:而缺乏这方面教育的孩子容易变得孤独，道德、情感与认知能力的发展都会受到一定的影响。 以下哪项与以上陈述方式最为类似?


        A、 老百姓过去“盼温饱”，现在“盼环保”;过去“求生存”，现在“求生态”。
        B、 脱离环境保护搞经济发展是“竭泽而渔”，离开经济发展抓环境保护是“缘木求鱼”。
        C、 只说一种语言的人，首次被诊断出患阿尔茨海默症的平均年龄约为 71 岁;说双语的人首次被诊
        断出患阿尔茨海默症的平均年龄约为 76 岁;说三种语言的人，首次被诊断出患阿尔茨海默症的
        平均年龄约为 78 岁。
        D、 注重调查研究，可以让我们掌握第一手资料:闭门造车，只能让我们脱离实际。
        E、 如果孩子完全依赖电子设备来进行学习和生活，将会对环境越来越漠视。

答：D

2. 赵明与王洪都是某高校辩论协会成员，在为今年华语辩论赛招募新队员问题上，两人发生了争执。 赵明:我们一定要选拔喜爱辩论的人。因为一个人只有喜爱辩论，才能投入精力和时间研究辩论并参 加辩论赛。 王洪:我们招募的不是辩论爱好者，而是能打硬仗的辩手。无论是谁，只要能在辩论赛中发挥应有的 作用，他就是我们理想的人选。
  以下哪项最可能是两人争论的焦点?
  
        A、 招募的标准是从现实出发还是从理想出发。
        B、 招募的标准是对辩论的爱好还是辩论的能力。
        C、 招募的目的是为了集体荣誉还是满足个人爱好。 
        D、 招募的目的是为了培养新人还是赢得比赛。
        E、 招募的目的是研究辩论规律还是培养实战能力。

答：D 

3. 生态文明建设事关社会发展方式和人民福祉。只有实行最严格的制度、最严密的法治，才能为生态文 明建设提供可靠保障;如果要实行最严格的制度、最严密的法治，就要建立责任追究制度，对那些不 顾生态环境盲目决策并造成严重后果者，追究其相应责任。
根据上述信息，可以得出以下哪项?

        A、 只有筑牢生态环境的制度防护墙，才能造福于民。
        B、 如果对那些不顾生态环境盲目决策并造成严重后果者追究相应责任，就能为生态文明建设提供可 靠保障。
        C、 实行最严格的制度和最严密的法治是生态文明建设的重要目标。
        D、 如果不建立责任追究制度，就不能为生态文明建设提供可靠保障。
        E、 如果要建立责任追究制度，就要实行最严格的制度、最严密的法治。

答：C

4. 研究人员发现，人类存在3种核苷酸基因类型:AA型、AG型以及GG型。一个人有36%的几率是AA型， 有 48%的几率是 AG 型，有 16%的几率是 GG 型。在 1200 名参与实验的老年人中，拥有 AA 型和 AG 型基 因类型的人都在上午 11 时之前去世，而拥有 GG 型基因类型的人几乎都在下午 6 时左右去世。研究人 员据此认为:GG 型基因类型的人会比其他人平均晚死 7 个小时。 以下哪项如果为真，最能质疑上述研究人员的观点?

        A、 拥有 GG 型基因类型的实验对象容易患上心血管疾病。
        B、 有些人是因为疾病或者意外事故等其他因素而死亡的。
        C、 对人死亡时间的比较，比一天中的哪一时刻更重要的是哪一年、哪一天。
        D、 当死亡临近的时候，人体会还原到一种更加自然的生理节奏感应阶段。
        E、 平均寿命的计算依据应是实验对象的生命存续长度，而不是实验对象的死亡时间。

答：D 

5. 人们一直在争论猫与狗谁更聪明。最近，有些科学家不仅研究了动物脑容量的大小，还研究了大脑皮 层神经细胞的数量，发现猫平常似乎总摆出一副智力占优的神态，但猫的大脑皮层神经细胞的数量只 有普通金毛犬的一半。由此，他们得出结论:狗比猫更聪明。 以下哪项最可能是上述科学家得出结论的假设?

        A、 动物大脑皮层神经细胞的数量与动物的聪明程度呈正相关。
        B、 狗善于与人类合作，可以充当导盲犬、陪护犬、搜救犬、警犬等，就对人类的贡献而言，狗能做
        的似乎比猫多。
        C、 狗可能继承了狼结群捕猎的特点，为了互相配合，它们需要做出一些复杂行为。
        D、 猫的神经细胞数量比狗少，是因为猫不像狗那样“爱交际”。
        E、 棕熊的脑容量是金毛犬的 3 倍,但其脑神经细胞的数量确少于金毛犬，与猫很接近，而棕熊的脑容
        量确是猫的 10 倍。

答：C 


### 语言特性(Java)(建议全做，时间控制在半小时以内)
1. 请写出以下程序的输出结果:

        public class Test {
            public static void main(String[] args) {
        String str1 = "he" + "llo";
        String str2 = "hello";
        String str3 = new String("hello");
        String str4 = new String("hello");
        StringBuilder str5 = new StringBuilder("hello"); StringBuilder str6 = new StringBuilder("hello");
        System.out.println(str1 == str2); System.out.println(str3 == str4); System.out.println(str5 == str6); System.out.println(str1.equals(str2)); System.out.println(str3.equals(str4)); System.out.println(str5.equals(str6));
        } }

答：

    true
    false
    false
    true
    true
    false


2. 请写出以下程序的输出结果;再写出将t.run()改成t.start()后的输出结果?

    
        public class HelloWorld {
            public static void main(String args[]) {
        Thread t = new Thread() { public void run() {
        pong(); }
        };
        t.run(); System.out.print("ping");
        }
             static void pong() {
               try {
        Thread.sleep(1000); } catch (Exception e) {
        System.out.println(e); }
        System.out.print("pong"); }
        }

答：

    pingpong
3. 请写出以下程序的输出结果:
        
         class HelloA {
            public HelloA() {
        System.out.println("HelloA"); }
        { System.out.println("I'm A class"); }
        static { System.out.println("static A"); } }
        public class HelloB extends HelloA {
            public HelloB() {
        System.out.println("HelloB"); }
        { System.out.println("I'm B class"); }
        static { System.out.println("static B"); }
            public static void main(String[] args) {
               new HelloB();
        } }

答：

    static A
    static B
    I'm A class
    HelloA
    I'm B class
    HelloB

4. 请写出以下程序的输出结果:

         class Base {
            public Base() {
        System.out.println("Base"); }
        public Base(int c) { System.out.println("Base--" + c);
        } }
        public class Derived extends Base {
            public Derived() {
        System.out.println("Derived"); }
            public Derived(int c) {
               super(c);
        System.out.println("Derived--" + c); }
        public static void main(String[] args) { Derived a = new Derived();
        Derived b = new Derived(33);
        } }

答：

    Base
    Derived
    Base--33
    Derived--33

5. 请写出以下程序的输出结果:

         public class Foo {
        String a = new String("hello"); StringBuilder b = new StringBuilder("okey");
        public static void main(String[] args) { Foo bar = new Foo(); bar.change(bar.a, bar.b); System.out.println(bar.a); System.out.println(bar.b);
        }
        
         public void change(String x, StringBuilder y) { x += " world";
        y.append(" dokey"); }
        }

答：

    hello
    okey dokey

6. 请写出以下程序的输出结果:

         import java.util.Map;
        import java.util.HashMap; import java.util.List;
        import java.util.ArrayList; import java.util.Collections; import java.util.Comparator;
        class Foo {
            public static <K extends Comparable<K>,V> Map<K,V> func(K[] k, V[] v) {
        Map<K,V> m = new HashMap<K,V>(); for (int i=0; i<k.length; i++) {
        m.put(k[i], v[i]); }
        List<Map.Entry<K,V>> l = new ArrayList<Map.Entry<K,V>>(m.entrySet()); Collections.sort(l, new Comparator<Map.Entry<K,V>>() {
        public int compare(Map.Entry<K,V> m1, Map.Entry<K,V> m2) { return m1.getKey().compareTo(m2.getKey());
        } });
        for (Map.Entry<K,V> e: l) { System.out.println(m.get(e.getKey()));
        }
        return m; }
        }
        public class Test {
            public static void main(String[] args) {
        String[] a = {"e", "a", "t"}; Integer[] b = {1, 6, 3}; Foo.<String,Integer>func(a, b); Foo.<Integer,String>func(b, a);
        } }

答：

    6
    1
    3
    e
    t
    a

7. 请写出以下程序的输出结果:


         public class Test {
            public static void main(String[] args) {
        Integer a = new Integer(200); int b = 200;
        Integer c = 200;
        Integer d = 200;
        Integer e = 3;
        Integer f = 3;
        Double g = 3.0;
        Double h = 3.0; System.out.println(a == b); System.out.println(a == c); System.out.println(c == d); System.out.println(e == f); System.out.println(g == h);
        } }

答：

    true
    false
    false
    true
    false

8. 请写出以下程序的输出结果:

         class A {
            public String f(double x) {
        return String.valueOf(x - 1); }
        protected String f(int x) { return String.valueOf(x * x);
        } }
        
          class B extends A {
            protected int f(char x) {
        return Integer.parseInt(String.valueOf(x) + x); }
        public String f(int x) {
        return String.valueOf(x + x);
        } }
        public class Foo {
            public static void main(String[] args) {
        B s = new B(); System.out.println(s.f(3.0)); System.out.println(s.f(3)); System.out.println(s.f('3'));
        } }

答：

    2.0
    6
    33

9. 请写出以下程序的输出结果:

    
        import java.util.Arrays;    
        public class Test {
            public static void main(String[] args) {
        int[] a= {1, 2, 3};
        a = Arrays.copyOf(a, a.length+1); for(int i: a) {
        System.out.println(a[i]); }
        } }


答：

    2
    3
    0
    1

10. 请写出以下程序的输出结果:

        interface A {
          StringBuilder s = new StringBuilder("ok"); }
        class B implements A {}
        class C implements A {}
        class Foo extends Exception {public Foo(String m) {super(m);}}
        class Bar extends Foo {public Bar(String m) {super(m);}}
        public class Test {
        public static String func() throws Exception {
        String ret = "dokey"; try {
        B b = new B();
        C c = new C();
        c.s.append("ey");
        if (b.s.toString().equals("okey")) {
        throw new Foo("Foo"); } else {
        throw new Bar("Bar"); }
        } catch (Bar e) { System.out.println(e.getMessage()); return ret;
        } catch (Foo e) { System.out.println(e.getMessage()); return ret;
        } finally { System.out.println("hello"); ret = "world";
        } }
        public static void main(String[] args) throws Exception { System.out.println(func());
        } }


答：

    Foo
    hello
    dokey




### 计算机网络、操作系统、数据库等(建议选做，这个部分是给不同方向不同背景的候选人准备的同一套 题，如果有不熟悉的知识点是正常的，请先看题，不熟悉的可直接略过。时间控制在二十分钟以内)
1. TCP建立连接需要进行 次握手，断开连接需要进行 次分手。

        三
        四


2. 请简要解释Cookie与Session的差别(三句话以内)。

        1）cookie是存储在浏览器中的，session是存储在服务端的
        2）存储大小有限制，cookie受浏览器限制，普遍4k，session理论受内存限制
        3）生命周期的控制：cookie的生命周期当浏览器关闭的时候就消亡了
        cookie的生命周期是累计的，从创建时就开始计时，30min后cookie生命周期结束
        session的生命周期是间隔的，从创建时开始计时如在30min内没有访问session，那么session生命周期就被销毁

3. 请分别用一句话解释下列HTTP状态码的意义: 
    
        301：永久性重定向
        302：临时移动
        400：客户端请求的语法错误，服务器无法理解
        500：服务器内部错误，无法完成请求
    

4. 请分别用一句话解释下列各 Linux 命令的用途:

        top: 查看cpu等
        mv: 移动文件等
        du: 查看磁盘占用
        chmod: 赋组权限
        awk: 处理文本，格式化
        uniq: 命令删除文件中的重复行
        ps: 显示当前进程状态
        grep: 管道
        find: 查找命令
        cat: 查看文件
        wc: 统计字符
        crontab: 定时任务
        netstat: 网络
        xargs: 传递参数
    

5. Linux操作系统中，对一个文件来说，rwx分别代表什么含义?

        r 代表可读、可访问;w 代表可写、可修改;x 代表可执行
    
6. 请简要解释进程与线程的差别(三句话以内)。

        1）从属关系不同：进程是正在运行程序的实例，进程中包含了线程，而线程中不能包含进程
        2）描述侧重点不同：进程是操作系统分配资源的单位，而线程是操作系统调度的基本单位
        3）共享资源不同：多个进程之间不能共享资源，每个进程有自己的堆、栈、虚存空间（页表）、文件描述符等信息。而线程之间可以共享进程资源文件（堆和方法区）
    

7. 请分别用一句话解释下列MySQL命令的用途。 explain: show processlist:

        explain：执行计划 
        show processlist：显示用户正在运行的线程
    

8. 请列举几个你最熟悉的软件设计模式(如单例模式)。
  
        单例模式
        策略模式
        门面模式
        抽象模板模式
        工厂模式
        代理模式

算法与编程能力(建议前三题全做，第四题选做，时间控制在一个小时左右)
1. 定义一个日志解析函数，接收一个字符串类型的参数，能够把字符串按如下格式返回。可以用任何语 言实现。
输入:2020-05-16 19:20:34|user.login|name=Charles&location=Beijing&device=iPhone 输出:

        {
        name:”Charles”,
        location:”Beijing”, device:”iPhone”
        }

答：

    public static void main(String[] args) {
        String input = "2020-05-16 19:20:34|user.login|name=Charles&location=Beijing&device=iPhone";

        String ret = doString(input);
        System.out.println("ret="+ret);
    }

    public static String doString(String input){
        int index = input.lastIndexOf("|");
        String org = input.substring(index+1);
        String[] orgArr = org.split("&");
        Map<String,String> map = new LinkedHashMap<>();
        for(String s : orgArr){
            String[] ss = s.split("=");
            map.put(ss[0],"\""+ss[1]+"\"");
        }

        return map.toString();
    }

2. 有一个已经排好序的整数序列(升序，无重复项)，序列中可能有正整数、负整数或者0，请用你认为 最优的方法求序列中绝对值最小的数。要求不能使用顺序比较的方法(时间复杂度需要小于 O(n))， 不能使用内置查找函数，可以用任何语言实现。
输入:一个有序的整数序列。
输出:绝对值最小的数。

答：

    
    public static void main(String[] args) {
        int[] input = {-11, -5, -2, 7, 15, 20};
        int ret = doInput(input);
        System.out.println("ret="+ret);
    }


    public static int doInput(int[] input) {
        if (input == null || input.length == 0) {
            return Integer.MIN_VALUE;
        }
        int len = input.length;
        if (input[0] >= 0) return input[0];//没有负数
        if (input[len - 1] < 0) return input[len - 1];//没有正数
        int mid = 0;
        int begin = 0;
        int end = len - 1;
        int absMin = 0;

        //数组中既有正数又有负数
        while (true) {
            mid = (begin + end) >>> 1;
            if (input[mid] == 0) {
                return 0;
            } else if (input[mid] > 0) {
                if (input[mid - 1] > 0) {
                    end = mid - 1;
                } else if (input[mid - 1] == 0) {
                    return 0;
                } else {
                    break;
                }
            } else {
                //如果值小于0，在数组右半部分查找
                if (input[mid] + 1 < 0) {
                    begin = mid + 1;
                } else if (input[mid] + 1 == 0) {
                    return 0;
                } else {
                    break;
                }
            }
        }

        if (input[mid] > 0) {
            if (input[mid] < Math.abs(input[mid - 1])) {
                absMin = input[mid];
            } else {
                absMin = input[mid - 1];
            }
        } else {
            if (Math.abs(input[mid]) < input[mid + 1]) {
                absMin = input[mid];
            } else {
                absMin = input[mid + 1];
            }
        }

        return absMin;

    }


3. 有一个无序的整数序列(无重复项，长度为奇数)，请用你认为最优的方法求序列的中位数。例如给 定数组 1、5、2、9、8、0、6，中位数是 5。要求算法的时间复杂度需要小于 O(n2)，不能使用内置排 序函数，可以用任何语言实现。
输入:一个无序的整数序列。
输出:中位数。

答：

    public static void main(String[] args) {
        int[] input = { 1,5,2,9,8,0,6};
        Double ret = doInput(input);
        System.out.println("ret="+ret);

    }


    public static Double doInput(int[] arr){
        //边界值
        if(arr == null || arr.length == 0){
            return null;
        }

        //考虑到arr长度为1时交由下面业务逻辑处理耗时也耗空间，此处做提前判断时间复杂度也才多O(1)
        if(arr.length == 1){
            return (double) arr[0];
        }

        // 默认是小顶堆，大顶堆为new PriorityQueue<>(Collections.reverseOrder())
        PriorityQueue<Integer> minPQ = new PriorityQueue<>();
        int length = arr.length;
        int k = length/2+1;

        for(int i = 0;i<k;i++){
            minPQ.add(arr[i]);
        }
        for(int i = k;i<length;i++){
            if(minPQ.peek() < arr[i]){
                minPQ.poll();
                minPQ.add(arr[i]);
            }
        }
        if (length % 2 == 0){
            return (minPQ.poll() + minPQ.peek())/ 2.0;
        } else{
            return minPQ.peek().doubleValue();
        }

    }


4. 【选做题】有一座高度是k级台阶的楼梯，从下往上走，每跨一步只能向上1级或者3级台阶。请用 你认为最优的方法求一共有多少种走法。例如给定楼梯台阶数 k 为 3，一共有 2 种走法。要求算法的 时间复杂度需要小于 O(2n)，可以用任何语言实现。
输入:楼梯台阶数 k。
输出:走法总数。

答一：


    public int getResultByRecursion(int n){
        if (n <1) {
            return 0;
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 1;
        }
        if (n == 3){
            return 2;
        }
        return getResultByRecursion(n-1) + getResultByRecursion(n-2)+ getResultByRecursion(n-3);
    }
    
答二：


    public int getResultByRecursion(int n){
        if (n <1) {
            return 0;
        }
        if (n == 1){
            return 1;
        }
        if (n == 2){
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int z = 1;
        int a = 1;
        int b = 2;
        int temp = 0;

        for (int i = 4; i < n+1 ; i++) {
            temp = a + b + z;
            z = a;
            a = b;
            b= temp;
        }
        return temp;
    }

