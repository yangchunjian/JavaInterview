(window.webpackJsonp=window.webpackJsonp||[]).push([[321],{1050:function(v,_,s){v.exports=s.p+"assets/img/20190117170720236.2a72dd7d.png"},2332:function(v,_,s){"use strict";s.r(_);var t=s(0),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"解答"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解答"}},[v._v("#")]),v._v(" 解答")]),v._v(" "),_("h1",{attrs:{id:"一、数据库为什么需要锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、数据库为什么需要锁"}},[v._v("#")]),v._v(" 一、数据库为什么需要锁？")]),v._v(" "),_("p",[v._v("为了保证数据的一致性。mysql数据库存在多种数据引擎，MySQL各存储引擎使用了三种类型（级别）的锁定机制："),_("code",[v._v("表级锁定，行级锁定和页级锁定")]),v._v("。")]),v._v(" "),_("h1",{attrs:{id:"二、表级锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、表级锁"}},[v._v("#")]),v._v(" 二、表级锁")]),v._v(" "),_("p",[v._v("1.表级锁（表级锁一次会将整个表锁定，所可以很好的避免死锁问题）")]),v._v(" "),_("p",[v._v("（1）锁定粒度大，锁冲突概率高、并发度低；")]),v._v(" "),_("p",[v._v("（2）好处是不会出现死锁、开销小、获取锁和释放锁的速度很快；")]),v._v(" "),_("p",[v._v("（3）使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎，适用于以查询为主，少量更新的应用。")]),v._v(" "),_("h1",{attrs:{id:"三、行级锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、行级锁"}},[v._v("#")]),v._v(" 三、行级锁")]),v._v(" "),_("p",[v._v("1.行级锁")]),v._v(" "),_("p",[v._v("（1）好处是锁定对象的颗粒度很小，发生锁冲突的概率低、并发度高；")]),v._v(" "),_("p",[v._v("（2）缺点是开销大、加锁慢，行级锁容易发生死锁；")]),v._v(" "),_("p",[v._v("（详解mysql死锁问题https://blog.csdn.net/Michaeles/article/details/86484716 ）")]),v._v(" "),_("p",[v._v("（3）使用行级锁定的主要是InnoDB存储引擎、及分布式存储引擎NDBCluster等。适用于对事务完整性要求较高的系统。InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁。")]),v._v(" "),_("p",[v._v("2.InnoDB行级锁类型")]),v._v(" "),_("p",[v._v("（1）共享锁：又称读锁，简单讲就是多个事务对同一数据进行共享一把锁，都能访问到数据，但是只能读不能修改。")]),v._v(" "),_("p",[v._v("（2）排他锁：又称写锁，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，只有获取排他锁的事务可以对数据进行读取和修改。")]),v._v(" "),_("p",[v._v("（3）意向锁是InnoDB自动加的，不需用户干预。意向锁不会与行级的共享 / 排他锁互斥！！！")]),v._v(" "),_("p",[v._v("3.注意事项")]),v._v(" "),_("p",[v._v("（1）排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。")]),v._v(" "),_("p",[v._v("（2）mysql InnoDb引擎中update,delete,insert语句自动加排他锁；")]),v._v(" "),_("p",[_("img",{attrs:{src:s(1050),alt:""}})]),v._v(" "),_("p",[v._v("//意向锁之间是互相兼容的，意向共享锁和普通共享锁之间是兼容的。")]),v._v(" "),_("p",[v._v("4.适用场景")]),v._v(" "),_("p",[v._v("（1）共享锁适用于：用来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作，如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁。")]),v._v(" "),_("p",[v._v("（2） 排他锁适用于：锁定行记录后需要进行更新操作的应用；")]),v._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",[_("code",[v._v("共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE\n排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE\n")])])]),_("p",[v._v("//https://www.cnblogs.com/boblogsbo/p/5602122.html")]),v._v(" "),_("p",[v._v("5.为什么使用意向锁？")]),v._v(" "),_("p",[v._v("提高了效率。")]),v._v(" "),_("p",[v._v("1.事务 A 先获取了某一行的 排他锁 ，并未提交：")]),v._v(" "),_("p",[v._v("SELECT * FROM users WHERE id = 6 FOR UPDATE;")]),v._v(" "),_("p",[v._v("（1）事务 A 获取了 users 表上的 意向排他锁 。\n（2）事务 A 获取了 id 为 6 的数据行上的 排他锁 。")]),v._v(" "),_("p",[v._v("2.事务 C 也想获取 users 表中某一行的 排他锁 ：")]),v._v(" "),_("p",[v._v("SELECT * FROM users WHERE id = 5 FOR UPDATE;")]),v._v(" "),_("p",[v._v("（1）事务 C 申请 users 表的 意向排他锁 。\n事务 C 检测到 事务 A 持有 users 表的 意向排他锁 。\n因为意向锁之间并不互斥，所以 事务 C 获取到了 users 表的 意向排他锁 。\n因为id 为 5 的数据行上不存在任何 排他锁 ，最终 事务 C 成功获取到了该数据行上的 排他锁 。")]),v._v(" "),_("h1",{attrs:{id:"四、页面锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四、页面锁"}},[v._v("#")]),v._v(" 四、页面锁")]),v._v(" "),_("p",[v._v("1.页面锁")]),v._v(" "),_("p",[v._v("（1）介于行级锁和表级锁之间；")]),v._v(" "),_("p",[v._v("（2）会发生死锁；")]),v._v(" "),_("p",[v._v("（3）BDB采用页面锁(page-level locking)或表级锁，默认为页面锁。")]),v._v(" "),_("h1",{attrs:{id:"五、关于锁的常见问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#五、关于锁的常见问题"}},[v._v("#")]),v._v(" 五、关于锁的常见问题")]),v._v(" "),_("p",[v._v("1.InnoDB存储引擎什么时候会锁住整张表（什么时候使用行级锁），什么时候或只锁住一行呢（使用行锁）？")]),v._v(" "),_("p",[v._v("只有通过索引条件查询数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 记住：一定要记住为匹配条件字段加索引。")]),v._v(" "),_("p",[v._v("2.什么时候使用行级锁？什么时候使用表级锁？")]),v._v(" "),_("p",[v._v("（1）在增删改查时匹配的条件字段不带有索引时，innodb使用的是表级锁，")]),v._v(" "),_("p",[v._v("3.行级锁锁的是什么？行级锁怎么实现加锁？")]),v._v(" "),_("p",[v._v("（1）行级锁是针对索引加的锁；")]),v._v(" "),_("p",[v._v("（2）InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。")]),v._v(" "),_("p",[v._v("4.mysql读锁和写锁？")]),v._v(" "),_("p",[v._v("（1）因为只有触发了读写锁，我们才会谈是进行行级锁定还是进行表级锁定；")]),v._v(" "),_("p",[v._v("（2）用select 命令时触发读锁，当使用update,delete,insert时触发写锁，并且使用rollback或commit后解除本次锁定。")]),v._v(" "),_("p",[v._v("5.常见的锁算法：")]),v._v(" "),_("p",[v._v("next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap")]),v._v(" "),_("p",[v._v("Gap锁，不锁记录，仅仅记录前面的Gap")]),v._v(" "),_("p",[v._v("Recordlock锁（锁数据，不锁Gap）")]),v._v(" "),_("p",[v._v("所以其实 Next-KeyLocks=Gap锁+ Recordlock锁")]),v._v(" "),_("p",[v._v("6.什么时候会释放锁？")]),v._v(" "),_("p",[_("code",[v._v("提交事务或回滚事务就会释放锁。")])])])}),[],!1,null,null,null);_.default=e.exports}}]);