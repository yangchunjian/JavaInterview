(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{1150:function(a,s,e){a.exports=e.p+"assets/img/cl1.42bf4392.png"},1151:function(a,s,e){a.exports=e.p+"assets/img/cl2.c957922b.png"},1152:function(a,s,e){a.exports=e.p+"assets/img/cl3.343a87c4.png"},1153:function(a,s,e){a.exports=e.p+"assets/img/cl4.52c5307a.png"},1154:function(a,s,e){a.exports=e.p+"assets/img/cl5.a82c04e6.png"},1155:function(a,s,e){a.exports=e.p+"assets/img/cl6.cb878e1e.png"},1156:function(a,s,e){a.exports=e.p+"assets/img/cl7.f8634da8.png"},1157:function(a,s,e){a.exports=e.p+"assets/img/cl8.b2264c5b.png"},1158:function(a,s,e){a.exports=e.p+"assets/img/cl9.cab6a39f.png"},1159:function(a,s,e){a.exports=e.p+"assets/img/cl10.b2264c5b.png"},1160:function(a,s,e){a.exports=e.p+"assets/img/cl11.23a92e1c.png"},1161:function(a,s,e){a.exports=e.p+"assets/img/cl12.33b5b7e7.png"},1162:function(a,s,e){a.exports=e.p+"assets/img/cl13.d327343b.png"},1163:function(a,s,e){a.exports=e.p+"assets/img/cl14.e1467cb5.png"},2463:function(a,s,e){"use strict";e.r(s);var t=e(0),n=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[a._v("ClassLoader翻译过来就是类加载器，普通的java开发者其实用到的不多，但对于某些框架开发者来说却非常常见。理解ClassLoader的加载机制，也有利于我们编写出更高效的代码。ClassLoader的具体作用就是将class文件加载到jvm虚拟机中去，程序就可以正确运行了。但是，jvm启动的时候，并不会一次性加载所有的class文件，而是根据需要去动态加载。想想也是的，一次性加载那么多jar包那么多class，那内存不崩溃。本文的目的也是学习ClassLoader这种加载机制。")]),a._v(" "),s("h2",{attrs:{id:"class文件的认识"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#class文件的认识"}},[a._v("#")]),a._v(" "),s("strong",[a._v("Class文件的认识")])]),a._v(" "),s("p",[a._v("我们都知道在Java中程序是运行在虚拟机中，我们平常用文本编辑器或者是IDE编写的程序都是.java格式的文件，这是最基础的源码，但这类文件是不能直接运行的。如我们编写一个简单的程序HelloWorld.java")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class HelloWorld{\n\n    public static void main(String[] args){\n        System.out.println("Hello world!");\n    }\n}\n')])])]),s("p",[a._v("如图：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1150),alt:""}})]),a._v(" "),s("p",[a._v("然后，我们需要在命令行中进行java文件的编译")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("javac HelloWorld.java\n")])])]),s("p",[s("img",{attrs:{src:e(1151),alt:""}})]),a._v(" "),s("p",[a._v("可以看到目录下生成了.class文件")]),a._v(" "),s("p",[a._v("我们再从命令行中执行命令：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("java HelloWorld\n")])])]),s("p",[s("img",{attrs:{src:e(1152),alt:""}})]),a._v(" "),s("p",[a._v("上面是基本代码示例，是所有入门JAVA语言时都学过的东西，这里重新拿出来是想让大家将焦点回到class文件上，class文件是字节码格式文件，java虚拟机并不能直接识别我们平常编写的.java源文件，所以需要javac这个命令转换成.class文件。另外，如果用C或者PYTHON编写的程序正确转换成.class文件后，java虚拟机也是可以识别运行的。更多信息大家可以参考这篇。")]),a._v(" "),s("p",[a._v("了解了.class文件后，我们再来思考下，我们平常在Eclipse中编写的java程序是如何运行的，也就是我们自己编写的各种类是如何被加载到jvm(java虚拟机)中去的。")]),a._v(" "),s("h2",{attrs:{id:"你还记得java环境变量吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#你还记得java环境变量吗"}},[a._v("#")]),a._v(" "),s("strong",[a._v("你还记得java环境变量吗？")])]),a._v(" "),s("p",[a._v("初学java的时候，最害怕的就是下载JDK后要配置环境变量了，关键是当时不理解，所以战战兢兢地照着书籍上或者是网络上的介绍进行操作。然后下次再弄的时候，又忘记了而且是必忘。当时，心里的想法很气愤的，想着是–这东西一点也不人性化，为什么非要自己配置环境变量呢？太不照顾菜鸟和新手了，很多菜鸟就是因为卡在环境变量的配置上，遭受了太多的挫败感。")]),a._v(" "),s("p",[a._v("因为我是在Windows下编程的，所以只讲Window平台上的环境变量，主要有3个：JAVA_HOME、PATH、CLASSPATH。")]),a._v(" "),s("p",[s("strong",[a._v("JAVA_HOME")])]),a._v(" "),s("p",[a._v("指的是你JDK安装的位置，一般默认安装在C盘，如")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("C:\\Program Files\\Java\\jdk1.8.0_91\n")])])]),s("p",[s("strong",[a._v("PATH")])]),a._v(" "),s("p",[a._v("将程序路径包含在PATH当中后，在命令行窗口就可以直接键入它的名字了，而不再需要键入它的全路径,比如上面代码中我用的到javac和java两个命令。\n一般的")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("PATH=%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;%PATH%;\n")])])]),s("p",[a._v("也就是在原来的PATH路径上添加JDK目录下的bin目录和jre目录的bin.")]),a._v(" "),s("p",[s("strong",[a._v("CLASSPATH")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar\n")])])]),s("p",[a._v("一看就是指向jar包路径。\n需要注意的是前面的.;，.代表当前目录。")]),a._v(" "),s("p",[s("strong",[a._v("环境变量的设置与查看")])]),a._v(" "),s("p",[a._v("设置可以右击我的电脑，然后点击属性，再点击高级，然后点击环境变量，具体不明白的自行查阅文档。")]),a._v(" "),s("p",[a._v("查看的话可以打开命令行窗口")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("echo %JAVA_HOME%\n\necho %PATH%\n\necho %CLASSPATH%\n")])])]),s("p",[a._v("好了，扯远了，知道了环境变量，特别是CLASSPATH时，我们进入今天的主题Classloader.")]),a._v(" "),s("h2",{attrs:{id:"java类加载流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java类加载流程"}},[a._v("#")]),a._v(" "),s("strong",[a._v("JAVA类加载流程")])]),a._v(" "),s("p",[a._v("Java语言系统自带有三个类加载器:")]),a._v(" "),s("ul",[s("li",[a._v("Bootstrap ClassLoader 最顶层的加载类，主要加载核心类库，%JRE_HOME%\\lib下的rt.jar、resources.jar、charsets.jar和class等。另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。")]),a._v(" "),s("li",[a._v("Extention ClassLoader 扩展的类加载器，加载目录%JRE_HOME%\\lib\\ext目录下的jar包和class文件。还可以加载-D java.ext.dirs选项指定的目录。")]),a._v(" "),s("li",[a._v("Appclass Loader也称为SystemAppClass 加载当前应用的classpath的所有类。")])]),a._v(" "),s("p",[a._v("我们上面简单介绍了3个ClassLoader。说明了它们加载的路径。并且还提到了-Xbootclasspath和-D java.ext.dirs这两个虚拟机参数选项。")]),a._v(" "),s("h2",{attrs:{id:"加载顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#加载顺序"}},[a._v("#")]),a._v(" "),s("strong",[a._v("加载顺序？")])]),a._v(" "),s("p",[a._v("我们看到了系统的3个类加载器，但我们可能不知道具体哪个先行呢？")]),a._v(" "),s("p",[a._v("我可以先告诉你答案")]),a._v(" "),s("ul",[s("li",[a._v("Bootstrap CLassloder")]),a._v(" "),s("li",[a._v("Extention ClassLoader")]),a._v(" "),s("li",[a._v("AppClassLoader")])]),a._v(" "),s("p",[a._v("为了更好的理解，我们可以查看源码。")]),a._v(" "),s("p",[a._v("看sun.misc.Launcher,它是一个java虚拟机的入口应用。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class Launcher {\n    private static Launcher launcher = new Launcher();\n    private static String bootClassPath =\n        System.getProperty("sun.boot.class.path");\n\n    public static Launcher getLauncher() {\n        return launcher;\n    }\n\n    private ClassLoader loader;\n\n    public Launcher() {\n        // Create the extension class loader\n        ClassLoader extcl;\n        try {\n            extcl = ExtClassLoader.getExtClassLoader();\n        } catch (IOException e) {\n            throw new InternalError(\n                "Could not create extension class loader", e);\n        }\n\n        // Now create the class loader to use to launch the application\n        try {\n            loader = AppClassLoader.getAppClassLoader(extcl);\n        } catch (IOException e) {\n            throw new InternalError(\n                "Could not create application class loader", e);\n        }\n\n        //设置AppClassLoader为线程上下文类加载器，这个文章后面部分讲解\n        Thread.currentThread().setContextClassLoader(loader);\n    }\n\n    /*\n     * Returns the class loader used to launch the main application.\n     */\n    public ClassLoader getClassLoader() {\n        return loader;\n    }\n    /*\n     * The class loader used for loading installed extensions.\n     */\n    static class ExtClassLoader extends URLClassLoader {}\n\n/**\n     * The class loader used for loading from java.class.path.\n     * runs in a restricted security context.\n     */\n    static class AppClassLoader extends URLClassLoader {}\n')])])]),s("p",[a._v("源码有精简，我们可以得到相关的信息。")]),a._v(" "),s("ul",[s("li",[a._v("Launcher初始化了ExtClassLoader和AppClassLoader。")]),a._v(" "),s("li",[a._v('Launcher中并没有看见BootstrapClassLoader，但通过System.getProperty("sun.boot.class.path")得到了字符串bootClassPath,这个应该就是BootstrapClassLoader加载的jar包路径。')])]),a._v(" "),s("p",[a._v("我们可以先代码测试一下sun.boot.class.path是什么内容。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('System.out.println(System.getProperty("sun.boot.class.path"));\n')])])]),s("p",[a._v("得到的结果是：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("C:\\Program Files\\Java\\jre1.8.0_91\\lib\\resources.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\lib\\rt.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\lib\\sunrsasign.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\lib\\jsse.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\lib\\jce.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\lib\\charsets.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\lib\\jfr.jar;\nC:\\Program Files\\Java\\jre1.8.0_91\\classes\n")])])]),s("p",[a._v("可以看到，这些全是JRE目录下的jar包或者是class文件。")]),a._v(" "),s("h2",{attrs:{id:"extclassloader源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#extclassloader源码"}},[a._v("#")]),a._v(" "),s("strong",[a._v("ExtClassLoader源码")])]),a._v(" "),s("p",[a._v("如果你有足够的好奇心，你应该会对它的源码感兴趣")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('/*\n * The class loader used for loading installed extensions.\n */\nstatic class ExtClassLoader extends URLClassLoader {\n\n    static {\n        ClassLoader.registerAsParallelCapable();\n    }\n\n    /**\n     * create an ExtClassLoader. The ExtClassLoader is created\n     * within a context that limits which files it can read\n     */\n    public static ExtClassLoader getExtClassLoader() throws IOException\n    {\n        final File[] dirs = getExtDirs();\n\n        try {\n            // Prior implementations of this doPrivileged() block supplied\n            // aa synthesized ACC via a call to the private method\n            // ExtClassLoader.getContext().\n\n            return AccessController.doPrivileged(\n                new PrivilegedExceptionAction<ExtClassLoader>() {\n                    public ExtClassLoader run() throws IOException {\n                        int len = dirs.length;\n                        for (int i = 0; i < len; i++) {\n                            MetaIndex.registerDirectory(dirs[i]);\n                        }\n                        return new ExtClassLoader(dirs);\n                    }\n                });\n        } catch (java.security.PrivilegedActionException e) {\n            throw (IOException) e.getException();\n        }\n    }\n\n    private static File[] getExtDirs() {\n        String s = System.getProperty("java.ext.dirs");\n        File[] dirs;\n        if (s != null) {\n            StringTokenizer st =\n                new StringTokenizer(s, File.pathSeparator);\n            int count = st.countTokens();\n            dirs = new File[count];\n            for (int i = 0; i < count; i++) {\n                dirs[i] = new File(st.nextToken());\n            }\n        } else {\n            dirs = new File[0];\n        }\n        return dirs;\n    }\n\n......\n    }\n')])])]),s("p",[a._v("我们先前的内容有说过，可以指定-D java.ext.dirs参数来添加和改变ExtClassLoader的加载路径。这里我们通过可以编写测试代码。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('System.out.println(System.getProperty("java.ext.dirs"));\n')])])]),s("p",[a._v("结果如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("C:\\Program Files\\Java\\jre1.8.0_91\\lib\\ext;C:\\Windows\\Sun\\Java\\lib\\ext\n")])])]),s("h2",{attrs:{id:"appclassloader源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#appclassloader源码"}},[a._v("#")]),a._v(" "),s("strong",[a._v("AppClassLoader源码")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('/**\n * The class loader used for loading from java.class.path.\n * runs in a restricted security context.\n */\nstatic class AppClassLoader extends URLClassLoader {\n\n\n    public static ClassLoader getAppClassLoader(final ClassLoader extcl)\n        throws IOException\n    {\n        final String s = System.getProperty("java.class.path");\n        final File[] path = (s == null) ? new File[0] : getClassPath(s);\n\n \n        return AccessController.doPrivileged(\n            new PrivilegedAction<AppClassLoader>() {\n                public AppClassLoader run() {\n                URL[] urls =\n                    (s == null) ? new URL[0] : pathToURLs(path);\n                return new AppClassLoader(urls, extcl);\n            }\n        });\n    }\n\n    ......\n}\n')])])]),s("p",[a._v("可以看到AppClassLoader加载的就是java.class.path下的路径。我们同样打印它的值。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('System.out.println(System.getProperty("java.class.path"));\n')])])]),s("p",[a._v("结果：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("D:\\workspace\\ClassLoaderDemo\\bin\n")])])]),s("p",[a._v("这个路径其实就是当前java工程目录bin，里面存放的是编译生成的class文件。")]),a._v(" "),s("p",[a._v("好了，自此我们已经知道了BootstrapClassLoader、ExtClassLoader、AppClassLoader实际是查阅相应的环境属性sun.boot.class.path、java.ext.dirs和java.class.path来加载资源文件的。")]),a._v(" "),s("p",[a._v("接下来我们探讨它们的加载顺序，我们先用Eclipse建立一个java工程。")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1153),alt:""}})]),a._v(" "),s("p",[a._v("然后创建一个Test.java文件。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("public class Test{}\n")])])]),s("p",[a._v("然后，编写一个ClassLoaderTest.java文件。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class ClassLoaderTest {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n    \n        ClassLoader cl = Test.class.getClassLoader();\n        \n        System.out.println("ClassLoader is:"+cl.toString());\n        \n    }\n\n}\n')])])]),s("p",[a._v("我们获取到了Test.class文件的类加载器，然后打印出来。结果是：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93  \n")])])]),s("p",[a._v("也就是说明Test.class文件是由AppClassLoader加载的。")]),a._v(" "),s("p",[a._v("这个Test类是我们自己编写的，那么int.class或者是String.class的加载是由谁完成的呢？\n我们可以在代码中尝试")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class ClassLoaderTest {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n    \n        ClassLoader cl = Test.class.getClassLoader();\n        \n        System.out.println("ClassLoader is:"+cl.toString());\n        \n        cl = int.class.getClassLoader();\n        \n        System.out.println("ClassLoader is:"+cl.toString());\n        \n    }\n\n}\n')])])]),s("p",[a._v("运行一下，却报错了")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93\nException in thread "main" java.lang.NullPointerException\n    at ClassLoaderTest.main(ClassLoaderTest.java:15)\n')])])]),s("p",[a._v("提示的是空指针，意思是int.class这类基础类没有类加载器加载？")]),a._v(" "),s("p",[a._v("当然不是！")]),a._v(" "),s("p",[a._v("int.class是由Bootstrap ClassLoader加载的。要想弄明白这些，我们首先得知道一个前提。")]),a._v(" "),s("h2",{attrs:{id:"每个类加载器都有一个父加载器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#每个类加载器都有一个父加载器"}},[a._v("#")]),a._v(" "),s("strong",[a._v("每个类加载器都有一个父加载器")])]),a._v(" "),s("p",[a._v("每个类加载器都有一个父加载器，比如加载Test.class是由AppClassLoader完成，那么AppClassLoader也有一个父加载器，怎么样获取呢？很简单，通过getParent方法。比如代码可以这样编写：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('ClassLoader cl = Test.class.getClassLoader();\n        \nSystem.out.println("ClassLoader is:"+cl.toString());\nSystem.out.println("ClassLoader\\\'s parent is:"+cl.getParent().toString());\n')])])]),s("p",[a._v("运行结果如下：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93\nClassLoader's parent is:sun.misc.Launcher$ExtClassLoader@15db9742\n")])])]),s("p",[a._v("这个说明，AppClassLoader的父加载器是ExtClassLoader。那么ExtClassLoader的父加载器又是谁呢？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('System.out.println("ClassLoader is:"+cl.toString());\nSystem.out.println("ClassLoader\\\'s parent is:"+cl.getParent().toString());\nSystem.out.println("ClassLoader\\\'s grand father is:"+cl.getParent().getParent().toString());\n')])])]),s("p",[a._v("运行如果：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('ClassLoader is:sun.misc.Launcher$AppClassLoader@73d16e93\nException in thread "main" ClassLoader\'s parent is:sun.misc.Launcher$ExtClassLoader@15db9742\njava.lang.NullPointerException\n    at ClassLoaderTest.main(ClassLoaderTest.java:13)\n')])])]),s("p",[a._v("又是一个空指针异常，这表明ExtClassLoader也没有父加载器。那么，为什么标题又是每一个加载器都有一个父加载器呢？这不矛盾吗？为了解释这一点，我们还需要看下面的一个基础前提。")]),a._v(" "),s("h2",{attrs:{id:"父加载器不是父类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#父加载器不是父类"}},[a._v("#")]),a._v(" "),s("strong",[a._v("父加载器不是父类")])]),a._v(" "),s("p",[a._v("我们先前已经粘贴了ExtClassLoader和AppClassLoader的代码。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("static class ExtClassLoader extends URLClassLoader {}\nstatic class AppClassLoader extends URLClassLoader {}\n")])])]),s("p",[a._v("可以看见ExtClassLoader和AppClassLoader同样继承自URLClassLoader，但上面一小节代码中，为什么调用AppClassLoader的getParent()代码会得到ExtClassLoader的实例呢？先从URLClassLoader说起，这个类又是什么？")]),a._v(" "),s("p",[a._v("先上一张类的继承关系图")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1154),alt:""}})]),a._v(" "),s("p",[a._v("URLClassLoader的源码中并没有找到getParent()方法。这个方法在ClassLoader.java中。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public abstract class ClassLoader {\n\n// The parent class loader for delegation\n// Note: VM hardcoded the offset of this field, thus all new fields\n// must be added *after* it.\nprivate final ClassLoader parent;\n// The class loader for the system\n    // @GuardedBy("ClassLoader.class")\nprivate static ClassLoader scl;\n\nprivate ClassLoader(Void unused, ClassLoader parent) {\n    this.parent = parent;\n    ...\n}\nprotected ClassLoader(ClassLoader parent) {\n    this(checkCreateClassLoader(), parent);\n}\nprotected ClassLoader() {\n    this(checkCreateClassLoader(), getSystemClassLoader());\n}\npublic final ClassLoader getParent() {\n    if (parent == null)\n        return null;\n    return parent;\n}\npublic static ClassLoader getSystemClassLoader() {\n    initSystemClassLoader();\n    if (scl == null) {\n        return null;\n    }\n    return scl;\n}\n\nprivate static synchronized void initSystemClassLoader() {\n    if (!sclSet) {\n        if (scl != null)\n            throw new IllegalStateException("recursive invocation");\n        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();\n        if (l != null) {\n            Throwable oops = null;\n            //通过Launcher获取ClassLoader\n            scl = l.getClassLoader();\n            try {\n                scl = AccessController.doPrivileged(\n                    new SystemClassLoaderAction(scl));\n            } catch (PrivilegedActionException pae) {\n                oops = pae.getCause();\n                if (oops instanceof InvocationTargetException) {\n                    oops = oops.getCause();\n                }\n            }\n            if (oops != null) {\n                if (oops instanceof Error) {\n                    throw (Error) oops;\n                } else {\n                    // wrap the exception\n                    throw new Error(oops);\n                }\n            }\n        }\n        sclSet = true;\n    }\n}\n}\n')])])]),s("p",[a._v("我们可以看到getParent()实际上返回的就是一个ClassLoader对象parent，parent的赋值是在ClassLoader对象的构造方法中，它有两个情况：")]),a._v(" "),s("ul",[s("li",[a._v("由外部类创建ClassLoader时直接指定一个ClassLoader为parent。")]),a._v(" "),s("li",[a._v("由getSystemClassLoader()方法生成，也就是在sun.misc.Laucher通过getClassLoader()获取，也就是AppClassLoader。直白的说，一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。")])]),a._v(" "),s("p",[a._v("我们主要研究的是ExtClassLoader与AppClassLoader的parent的来源，正好它们与Launcher类有关，我们上面已经粘贴过Launcher的部分代码。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class Launcher {\n    private static URLStreamHandlerFactory factory = new Factory();\n    private static Launcher launcher = new Launcher();\n    private static String bootClassPath =\n        System.getProperty("sun.boot.class.path");\n\n    public static Launcher getLauncher() {\n        return launcher;\n    }\n\n    private ClassLoader loader;\n\n    public Launcher() {\n        // Create the extension class loader\n        ClassLoader extcl;\n        try {\n            extcl = ExtClassLoader.getExtClassLoader();\n        } catch (IOException e) {\n            throw new InternalError(\n                "Could not create extension class loader", e);\n        }\n\n        // Now create the class loader to use to launch the application\n        try {\n        //将ExtClassLoader对象实例传递进去\n            loader = AppClassLoader.getAppClassLoader(extcl);\n        } catch (IOException e) {\n            throw new InternalError(\n                "Could not create application class loader", e);\n        }\n\npublic ClassLoader getClassLoader() {\n        return loader;\n    }\nstatic class ExtClassLoader extends URLClassLoader {\n\n        /**\n         * create an ExtClassLoader. The ExtClassLoader is created\n         * within a context that limits which files it can read\n         */\n        public static ExtClassLoader getExtClassLoader() throws IOException\n        {\n            final File[] dirs = getExtDirs();\n\n            try {\n                // Prior implementations of this doPrivileged() block supplied\n                // aa synthesized ACC via a call to the private method\n                // ExtClassLoader.getContext().\n\n                return AccessController.doPrivileged(\n                    new PrivilegedExceptionAction<ExtClassLoader>() {\n                        public ExtClassLoader run() throws IOException {\n                            //ExtClassLoader在这里创建\n                            return new ExtClassLoader(dirs);\n                        }\n                    });\n            } catch (java.security.PrivilegedActionException e) {\n                throw (IOException) e.getException();\n            }\n        }\n\n\n        /*\n         * Creates a new ExtClassLoader for the specified directories.\n         */\n        public ExtClassLoader(File[] dirs) throws IOException {\n            super(getExtURLs(dirs), null, factory);\n           \n        }\n        }\n }\n')])])]),s("p",[a._v("我们需要注意的是")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("ClassLoader extcl;\n        \nextcl = ExtClassLoader.getExtClassLoader();\n\nloader = AppClassLoader.getAppClassLoader(extcl);\n")])])]),s("p",[a._v("代码已经说明了问题AppClassLoader的parent是一个ExtClassLoader实例。")]),a._v(" "),s("p",[a._v("ExtClassLoader并没有直接找到对parent的赋值。它调用了它的父类也就是URLClassLoder的构造方法并传递了3个参数。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("public ExtClassLoader(File[] dirs) throws IOException {\n            super(getExtURLs(dirs), null, factory);   \n}\n")])])]),s("p",[a._v("对应的代码")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("public  URLClassLoader(URL[] urls, ClassLoader parent,\n                          URLStreamHandlerFactory factory) {\n     super(parent);\n}\n")])])]),s("p",[a._v("答案已经很明了了，ExtClassLoader的parent为null。")]),a._v(" "),s("p",[a._v("上面张贴这么多代码也是为了说明AppClassLoader的parent是ExtClassLoader，ExtClassLoader的parent是null。这符合我们之前编写的测试代码。")]),a._v(" "),s("p",[a._v("不过，细心的同学发现，还是有疑问的我们只看到ExtClassLoader和AppClassLoader的创建，那么BootstrapClassLoader呢？")]),a._v(" "),s("p",[a._v("还有，ExtClassLoader的父加载器为null,但是Bootstrap CLassLoader却可以当成它的父加载器这又是为何呢？")]),a._v(" "),s("p",[a._v("我们继续往下进行。")]),a._v(" "),s("h2",{attrs:{id:"bootstrap-classloader是由c-编写的。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bootstrap-classloader是由c-编写的。"}},[a._v("#")]),a._v(" "),s("strong",[a._v("Bootstrap ClassLoader是由C++编写的。")])]),a._v(" "),s("p",[a._v("Bootstrap ClassLoader是由C/C++编写的，它本身是虚拟机的一部分，所以它并不是一个JAVA类，也就是无法在java代码中获取它的引用，JVM启动时通过Bootstrap类加载器加载rt.jar等核心jar包中的class文件，之前的int.class,String.class都是由它加载。然后呢，我们前面已经分析了，JVM初始化sun.misc.Launcher并创建Extension ClassLoader和AppClassLoader实例。并将ExtClassLoader设置为AppClassLoader的父加载器。Bootstrap没有父加载器，但是它却可以作用一个ClassLoader的父加载器。比如ExtClassLoader。这也可以解释之前通过ExtClassLoader的getParent方法获取为Null的现象。具体是什么原因，很快就知道答案了。")]),a._v(" "),s("p",[s("strong",[a._v("双亲委托")])]),a._v(" "),s("p",[s("strong",[a._v("双亲委托。")])]),a._v(" "),s("p",[a._v("我们终于来到了这一步了。")]),a._v(" "),s("p",[a._v("一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。\n整个流程可以如下图所示：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1155),alt:""}})]),a._v(" "),s("p",[a._v("这张图是用时序图画出来的，不过画出来的结果我却自己都觉得不理想。")]),a._v(" "),s("p",[a._v("大家可以看到2根箭头，蓝色的代表类加载器向上委托的方向，如果当前的类加载器没有查询到这个class对象已经加载就请求父加载器（不一定是父类）进行操作，然后以此类推。直到Bootstrap ClassLoader。如果Bootstrap ClassLoader也没有加载过此class实例，那么它就会从它指定的路径中去查找，如果查找成功则返回，如果没有查找成功则交给子类加载器，也就是ExtClassLoader,这样类似操作直到终点，也就是我上图中的红色箭头示例。")]),a._v(" "),s("p",[a._v("用序列描述一下：")]),a._v(" "),s("ul",[s("li",[a._v("一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。")]),a._v(" "),s("li",[a._v("递归，重复第1部的操作。")]),a._v(" "),s("li",[a._v("如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。")]),a._v(" "),s("li",[a._v("Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。")]),a._v(" "),s("li",[a._v("ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。")])]),a._v(" "),s("p",[a._v("上面的序列，详细说明了双亲委托的加载流程。我们可以发现委托是从下向上，然后具体查找过程却是自上至下。")]),a._v(" "),s("p",[a._v("我说过上面用时序图画的让自己不满意，现在用框图，最原始的方法再画一次。")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1156),alt:""}})]),a._v(" "),s("p",[a._v("上面已经详细介绍了加载过程，但具体为什么是这样加载，我们还需要了解几个个重要的方法loadClass()、findLoadedClass()、findClass()、defineClass()。")]),a._v(" "),s("h2",{attrs:{id:"重要方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重要方法"}},[a._v("#")]),a._v(" "),s("strong",[a._v("重要方法")])]),a._v(" "),s("p",[s("strong",[a._v("loadClass()")])]),a._v(" "),s("p",[a._v("JDK文档中是这样写的，通过指定的全限定类名加载class，它通过同名的loadClass(String,boolean)方法。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("protected Class<?> loadClass(String name,\n                             boolean resolve)\n                      throws ClassNotFoundException\n")])])]),s("p",[a._v("上面是方法原型，一般实现这个方法的步骤是")]),a._v(" "),s("ul",[s("li",[a._v("执行findLoadedClass(String)去检测这个class是不是已经加载过了。")]),a._v(" "),s("li",[a._v("执行父加载器的loadClass方法。如果父加载器为null，则jvm内置的加载器去替代，也就是Bootstrap ClassLoader。这也解释了ExtClassLoader的parent为null,但仍然说Bootstrap ClassLoader是它的父加载器。")]),a._v(" "),s("li",[a._v("如果向上委托父加载器没有加载成功，则通过findClass(String)查找。")])]),a._v(" "),s("p",[a._v("如果class在上面的步骤中找到了，参数resolve又是true的话，那么loadClass()又会调用resolveClass(Class)这个方法来生成最终的Class对象。 我们可以从源代码看出这个步骤。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("protected Class<?> loadClass(String name, boolean resolve)\n        throws ClassNotFoundException\n    {\n        synchronized (getClassLoadingLock(name)) {\n            // 首先，检测是否已经加载\n            Class<?> c = findLoadedClass(name);\n            if (c == null) {\n                long t0 = System.nanoTime();\n                try {\n                    if (parent != null) {\n                        //父加载器不为空则调用父加载器的loadClass\n                        c = parent.loadClass(name, false);\n                    } else {\n                        //父加载器为空则调用Bootstrap Classloader\n                        c = findBootstrapClassOrNull(name);\n                    }\n                } catch (ClassNotFoundException e) {\n                    // ClassNotFoundException thrown if class not found\n                    // from the non-null parent class loader\n                }\n\n                if (c == null) {\n                    // If still not found, then invoke findClass in order\n                    // to find the class.\n                    long t1 = System.nanoTime();\n                    //父加载器没有找到，则调用findclass\n                    c = findClass(name);\n\n                    // this is the defining class loader; record the stats\n                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                    sun.misc.PerfCounter.getFindClasses().increment();\n                }\n            }\n            if (resolve) {\n                //调用resolveClass()\n                resolveClass(c);\n            }\n            return c;\n        }\n    }\n")])])]),s("p",[a._v("代码解释了双亲委托。")]),a._v(" "),s("p",[a._v("另外，要注意的是如果要编写一个classLoader的子类，也就是自定义一个classloader，建议覆盖findClass()方法，而不要直接改写loadClass()方法。")]),a._v(" "),s("p",[a._v("另外")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("if (parent != null) {\n    //父加载器不为空则调用父加载器的loadClass\n    c = parent.loadClass(name, false);\n} else {\n    //父加载器为空则调用Bootstrap Classloader\n    c = findBootstrapClassOrNull(name);\n}\n")])])]),s("p",[a._v("前面说过ExtClassLoader的parent为null，所以它向上委托时，系统会为它指定Bootstrap ClassLoader。")]),a._v(" "),s("h2",{attrs:{id:"自定义classloader"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义classloader"}},[a._v("#")]),a._v(" "),s("strong",[a._v("自定义ClassLoader")])]),a._v(" "),s("p",[a._v("不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？")]),a._v(" "),s("p",[a._v("如果要这样做的话，需要我们自定义一个classloader。")]),a._v(" "),s("p",[s("strong",[a._v("自定义步骤")])]),a._v(" "),s("ul",[s("li",[a._v("编写一个类继承自ClassLoader抽象类。")]),a._v(" "),s("li",[a._v("复写它的findClass()方法。")]),a._v(" "),s("li",[a._v("在findClass()方法中调用defineClass()。")])]),a._v(" "),s("p",[s("strong",[a._v("defineClass()")])]),a._v(" "),s("p",[a._v("这个方法在编写自定义classloader的时候非常重要，它能将class二进制内容转换成Class对象，如果不符合要求的会抛出各种异常。")]),a._v(" "),s("p",[s("strong",[a._v("注意点：")])]),a._v(" "),s("p",[a._v("**一个ClassLoader创建时如果没有指定parent，那么它的parent默认就是AppClassLoader。 **")]),a._v(" "),s("p",[a._v("上面说的是，如果自定义一个ClassLoader，默认的parent父加载器是AppClassLoader，因为这样就能够保证它能访问系统内置加载器加载成功的class文件。")]),a._v(" "),s("h2",{attrs:{id:"自定义classloader示例之diskclassloader。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义classloader示例之diskclassloader。"}},[a._v("#")]),a._v(" "),s("strong",[a._v("自定义ClassLoader示例之DiskClassLoader。")])]),a._v(" "),s("p",[a._v("假设我们需要一个自定义的classloader,默认加载路径为D:\\lib下的jar包和资源。")]),a._v(" "),s("p",[a._v("我们写编写一个测试用的类文件，Test.java")]),a._v(" "),s("p",[a._v("Test.java")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('package com.frank.test;\n\npublic class Test {\n    \n    public void say(){\n        System.out.println("Say Hello");\n    }\n\n}\n')])])]),s("p",[a._v("然后将它编译过年class文件Test.class放到D:\\lib这个路径下。")]),a._v(" "),s("p",[a._v("DiskClassLoader")]),a._v(" "),s("p",[a._v("我们编写DiskClassLoader的代码。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('import java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n\npublic class DiskClassLoader extends ClassLoader {\n    \n    private String mLibPath;\n    \n    public DiskClassLoader(String path) {\n        // TODO Auto-generated constructor stub\n        mLibPath = path;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        // TODO Auto-generated method stub\n        \n        String fileName = getFileName(name);\n        \n        File file = new File(mLibPath,fileName);\n        \n        try {\n            FileInputStream is = new FileInputStream(file);\n            \n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            int len = 0;\n            try {\n                while ((len = is.read()) != -1) {\n                    bos.write(len);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            \n            byte[] data = bos.toByteArray();\n            is.close();\n            bos.close();\n            \n            return defineClass(name,data,0,data.length);\n            \n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        return super.findClass(name);\n    }\n\n    //获取要加载 的class文件名\n    private String getFileName(String name) {\n        // TODO Auto-generated method stub\n        int index = name.lastIndexOf(\'.\');\n        if(index == -1){ \n            return name+".class";\n        }else{\n            return name.substring(index+1)+".class";\n        }\n    }\n    \n}\n')])])]),s("p",[a._v("我们在findClass()方法中定义了查找class的方法，然后数据通过defineClass()生成了Class对象。")]),a._v(" "),s("p",[s("strong",[a._v("测试")])]),a._v(" "),s("p",[a._v('现在我们要编写测试代码。我们知道如果调用一个Test对象的say方法，它会输出"Say Hello"这条字符串。但现在是我们把Test.class放置在应用工程所有的目录之外，我们需要加载它，然后执行它的方法。具体效果如何呢？我们编写的DiskClassLoader能不能顺利完成任务呢？我们拭目以待。')]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('import java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ClassLoaderTest {\n\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n    \n        //创建自定义classloader对象。\n        DiskClassLoader diskLoader = new DiskClassLoader("D:\\\\lib");\n        try {\n            //加载class文件\n            Class c = diskLoader.loadClass("com.frank.test.Test");\n            \n            if(c != null){\n                try {\n                    Object obj = c.newInstance();\n                    Method method = c.getDeclaredMethod("say",null);\n                    //通过反射调用Test类的say方法\n                    method.invoke(obj, null);\n                } catch (InstantiationException | IllegalAccessException \n                        | NoSuchMethodException\n                        | SecurityException | \n                        IllegalArgumentException | \n                        InvocationTargetException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n    }\n\n}\n')])])]),s("p",[a._v("我们点击运行按钮，结果显示。")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1157),alt:""}})]),a._v(" "),s("p",[a._v("可以看到，Test类的say方法正确执行，也就是我们写的DiskClassLoader编写成功。")]),a._v(" "),s("h2",{attrs:{id:"回首"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回首"}},[a._v("#")]),a._v(" "),s("strong",[a._v("回首")])]),a._v(" "),s("p",[a._v("讲了这么大的篇幅，自定义ClassLoader才姗姗来迟。 很多同学可能觉得前面有些啰嗦，但我按照自己的思路，我觉得还是有必要的。因为我是围绕一个关键字进行讲解的。")]),a._v(" "),s("p",[s("strong",[a._v("关键字是什么？")])]),a._v(" "),s("p",[s("strong",[a._v("关键字 路径")])]),a._v(" "),s("ul",[s("li",[a._v("从开篇的环境变量")]),a._v(" "),s("li",[a._v("到3个主要的JDK自带的类加载器")]),a._v(" "),s("li",[a._v("到自定义的ClassLoader")])]),a._v(" "),s("p",[a._v("它们的关联部分就是路径，也就是要加载的class或者是资源的路径。")]),a._v(" "),s("p",[a._v("BootStrap ClassLoader、ExtClassLoader、AppClassLoader都是加载指定路径下的jar包。如果我们要突破这种限制，实现自己某些特殊的需求，我们就得自定义ClassLoader，自已指定加载的路径，可以是磁盘、内存、网络或者其它。")]),a._v(" "),s("p",[s("strong",[a._v("所以，你说路径能不能成为它们的关键字？")])]),a._v(" "),s("p",[a._v("当然上面的只是我个人的看法，可能不正确，但现阶段，这样有利于自己的学习理解。")]),a._v(" "),s("p",[s("strong",[a._v("自定义ClassLoader还能做什么？")])]),a._v(" "),s("p",[a._v("突破了JDK系统内置加载路径的限制之后，我们就可以编写自定义ClassLoader，然后剩下的就叫给开发者你自己了。你可以按照自己的意愿进行业务的定制，将ClassLoader玩出花样来。")]),a._v(" "),s("p",[s("strong",[a._v("玩出花之Class解密类加载器")])]),a._v(" "),s("p",[a._v("常见的用法是将Class文件按照某种加密手段进行加密，然后按照规则编写自定义的ClassLoader进行解密，这样我们就可以在程序中加载特定了类，并且这个类只能被我们自定义的加载器进行加载，提高了程序的安全性。")]),a._v(" "),s("p",[a._v("下面，我们编写代码。")]),a._v(" "),s("p",[s("strong",[a._v("1.定义加密解密协议")])]),a._v(" "),s("p",[a._v("加密和解密的协议有很多种，具体怎么定看业务需要。在这里，为了便于演示，我简单地将加密解密定义为异或运算。当一个文件进行异或运算后，产生了加密文件，再进行一次异或后，就进行了解密。")]),a._v(" "),s("p",[s("strong",[a._v("2.编写加密工具类")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\n\npublic class FileUtils {\n    \n    public static void test(String path){\n        File file = new File(path);\n        try {\n            FileInputStream fis = new FileInputStream(file);\n            FileOutputStream fos = new FileOutputStream(path+"en");\n            int b = 0;\n            int b1 = 0;\n            try {\n                while((b = fis.read()) != -1){\n                    //每一个byte异或一个数字2\n                    fos.write(b ^ 2);\n                }\n                fos.close();\n                fis.close();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n}\n')])])]),s("p",[a._v("我们再写测试代码")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('FileUtils.test("D:\\\\lib\\\\Test.class");\n')])])]),s("p",[s("img",{attrs:{src:e(1158),alt:""}})]),a._v(" "),s("p",[a._v("然后可以看见路径D:\\lib\\Test.class下Test.class生成了Test.classen文件。")]),a._v(" "),s("p",[s("strong",[a._v("编写自定义classloader，DeClassLoader")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('import java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n\npublic class DeClassLoader extends ClassLoader {\n    \n    private String mLibPath;\n    \n    public DeClassLoader(String path) {\n        // TODO Auto-generated constructor stub\n        mLibPath = path;\n    }\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        // TODO Auto-generated method stub\n        \n        String fileName = getFileName(name);\n        \n        File file = new File(mLibPath,fileName);\n        \n        try {\n            FileInputStream is = new FileInputStream(file);\n            \n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            int len = 0;\n            byte b = 0;\n            try {\n                while ((len = is.read()) != -1) {\n                    //将数据异或一个数字2进行解密\n                    b = (byte) (len ^ 2);\n                    bos.write(b);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            \n            byte[] data = bos.toByteArray();\n            is.close();\n            bos.close();\n            \n            return defineClass(name,data,0,data.length);\n            \n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        return super.findClass(name);\n    }\n\n    //获取要加载 的class文件名\n    private String getFileName(String name) {\n        // TODO Auto-generated method stub\n        int index = name.lastIndexOf(\'.\');\n        if(index == -1){ \n            return name+".classen";\n        }else{\n            return name.substring(index+1)+".classen";\n        }\n    }\n    \n}\n')])])]),s("p",[s("strong",[a._v("测试")])]),a._v(" "),s("p",[a._v("我们可以在ClassLoaderTest.java中的main方法中如下编码：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('DeClassLoader diskLoader = new DeClassLoader("D:\\\\lib");\n        try {\n            //加载class文件\n            Class c = diskLoader.loadClass("com.frank.test.Test");\n            \n            if(c != null){\n                try {\n                    Object obj = c.newInstance();\n                    Method method = c.getDeclaredMethod("say",null);\n                    //通过反射调用Test类的say方法\n                    method.invoke(obj, null);\n                } catch (InstantiationException | IllegalAccessException \n                        | NoSuchMethodException\n                        | SecurityException | \n                        IllegalArgumentException | \n                        InvocationTargetException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n')])])]),s("p",[a._v("查看运行结果是：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1159),alt:""}})]),a._v(" "),s("p",[a._v("可以看到了，同样成功了。现在，我们有两个自定义的ClassLoader:DiskClassLoader和DeClassLoader，我们可以尝试一下，看看DiskClassLoader能不能加载Test.classen文件也就是Test.class加密后的文件。")]),a._v(" "),s("p",[a._v("我们首先移除D:\\lib\\Test.class文件，只剩下一下Test.classen文件，然后进行代码的测试。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('DeClassLoader diskLoader1 = new DeClassLoader("D:\\\\lib");\n        try {\n            //加载class文件\n            Class c = diskLoader1.loadClass("com.frank.test.Test");\n            \n            if(c != null){\n                try {\n                    Object obj = c.newInstance();\n                    Method method = c.getDeclaredMethod("say",null);\n                    //通过反射调用Test类的say方法\n                    method.invoke(obj, null);\n                } catch (InstantiationException | IllegalAccessException \n                        | NoSuchMethodException\n                        | SecurityException | \n                        IllegalArgumentException | \n                        InvocationTargetException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        DiskClassLoader diskLoader = new DiskClassLoader("D:\\\\lib");\n        try {\n            //加载class文件\n            Class c = diskLoader.loadClass("com.frank.test.Test");\n            \n            if(c != null){\n                try {\n                    Object obj = c.newInstance();\n                    Method method = c.getDeclaredMethod("say",null);\n                    //通过反射调用Test类的say方法\n                    method.invoke(obj, null);\n                } catch (InstantiationException | IllegalAccessException \n                        | NoSuchMethodException\n                        | SecurityException | \n                        IllegalArgumentException | \n                        InvocationTargetException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n    }\n')])])]),s("p",[a._v("运行结果：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1160),alt:""}})]),a._v(" "),s("p",[a._v("我们可以看到。DeClassLoader运行正常，而DiskClassLoader却找不到Test.class的类,并且它也无法加载Test.classen文件。")]),a._v(" "),s("h2",{attrs:{id:"context-classloader-线程上下文类加载器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#context-classloader-线程上下文类加载器"}},[a._v("#")]),a._v(" "),s("strong",[a._v("Context ClassLoader 线程上下文类加载器")])]),a._v(" "),s("p",[a._v("前面讲到过Bootstrap ClassLoader、ExtClassLoader、AppClassLoader，现在又出来这么一个类加载器，这是为什么？")]),a._v(" "),s("p",[a._v("前面三个之所以放在前面讲，是因为它们是真实存在的类，而且遵从”双亲委托“的机制。而ContextClassLoader其实只是一个概念。")]),a._v(" "),s("p",[a._v("查看Thread.java源码可以发现")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('public class Thread implements Runnable {\n\n/* The context ClassLoader for this thread */\n   private ClassLoader contextClassLoader;\n   \n   public void setContextClassLoader(ClassLoader cl) {\n       SecurityManager sm = System.getSecurityManager();\n       if (sm != null) {\n           sm.checkPermission(new RuntimePermission("setContextClassLoader"));\n       }\n       contextClassLoader = cl;\n   }\n\n   public ClassLoader getContextClassLoader() {\n       if (contextClassLoader == null)\n           return null;\n       SecurityManager sm = System.getSecurityManager();\n       if (sm != null) {\n           ClassLoader.checkClassLoaderPermission(contextClassLoader,\n                                                  Reflection.getCallerClass());\n       }\n       return contextClassLoader;\n   }\n}\n')])])]),s("p",[a._v("contextClassLoader只是一个成员变量，通过setContextClassLoader()方法设置，通过getContextClassLoader()设置。")]),a._v(" "),s("p",[a._v("每个Thread都有一个相关联的ClassLoader，默认是AppClassLoader。并且子线程默认使用父线程的ClassLoader除非子线程特别设置。")]),a._v(" "),s("p",[a._v("我们同样可以编写代码来加深理解。")]),a._v(" "),s("p",[a._v("现在有2个SpeakTest.class文件，一个源码是")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('package com.frank.test;\n\npublic class SpeakTest implements ISpeak {\n\n    @Override\n    public void speak() {\n        // TODO Auto-generated method stub\n        System.out.println("Test");\n    }\n\n}\n')])])]),s("p",[a._v("它生成的SpeakTest.class文件放置在D:\\lib\\test目录下。\n另外ISpeak.java代码")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("package com.frank.test;\n\npublic interface ISpeak {\n    public void speak();\n\n}\n")])])]),s("p",[a._v("然后，我们在这里还实现了一个SpeakTest.java")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('package com.frank.test;\n\npublic class SpeakTest implements ISpeak {\n\n    @Override\n    public void speak() {\n        // TODO Auto-generated method stub\n        System.out.println("I\\\' frank");\n    }\n\n}\n')])])]),s("p",[a._v("它生成的SpeakTest.class文件放置在D:\\lib目录下。")]),a._v(" "),s("p",[a._v("然后我们还要编写另外一个ClassLoader，DiskClassLoader1.java这个ClassLoader的代码和DiskClassLoader.java代码一致，我们要在DiskClassLoader1中加载位置于D:\\lib\\test中的SpeakTest.class文件。")]),a._v(" "),s("p",[a._v("测试代码：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v('DiskClassLoader1 diskLoader1 = new DiskClassLoader1("D:\\\\lib\\\\test");\nClass cls1 = null;\ntry {\n//加载class文件\n cls1 = diskLoader1.loadClass("com.frank.test.SpeakTest");\nSystem.out.println(cls1.getClassLoader().toString());\nif(cls1 != null){\n    try {\n        Object obj = cls1.newInstance();\n        //SpeakTest1 speak = (SpeakTest1) obj;\n        //speak.speak();\n        Method method = cls1.getDeclaredMethod("speak",null);\n        //通过反射调用Test类的speak方法\n        method.invoke(obj, null);\n    } catch (InstantiationException | IllegalAccessException \n            | NoSuchMethodException\n            | SecurityException | \n            IllegalArgumentException | \n            InvocationTargetException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n} catch (ClassNotFoundException e) {\n// TODO Auto-generated catch block\ne.printStackTrace();\n}\n    \nDiskClassLoader diskLoader = new DiskClassLoader("D:\\\\lib");\nSystem.out.println("Thread "+Thread.currentThread().getName()+" classloader: "+Thread.currentThread().getContextClassLoader().toString());\nnew Thread(new Runnable() {\n    \n    @Override\n    public void run() {\n        System.out.println("Thread "+Thread.currentThread().getName()+" classloader: "+Thread.currentThread().getContextClassLoader().toString());\n        \n        // TODO Auto-generated method stub\n        try {\n            //加载class文件\n        //\tThread.currentThread().setContextClassLoader(diskLoader);\n            //Class c = diskLoader.loadClass("com.frank.test.SpeakTest");\n            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n            Class c = cl.loadClass("com.frank.test.SpeakTest");\n            // Class c = Class.forName("com.frank.test.SpeakTest");\n            System.out.println(c.getClassLoader().toString());\n            if(c != null){\n                try {\n                    Object obj = c.newInstance();\n                    //SpeakTest1 speak = (SpeakTest1) obj;\n                    //speak.speak();\n                    Method method = c.getDeclaredMethod("speak",null);\n                    //通过反射调用Test类的say方法\n                    method.invoke(obj, null);\n                } catch (InstantiationException | IllegalAccessException \n                        | NoSuchMethodException\n                        | SecurityException | \n                        IllegalArgumentException | \n                        InvocationTargetException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}).start();\n')])])]),s("p",[a._v("结果如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1161),alt:""}})]),a._v(" "),s("p",[a._v("我们可以得到如下的信息：")]),a._v(" "),s("ul",[s("li",[a._v("DiskClassLoader1加载成功了SpeakTest.class文件并执行成功。")]),a._v(" "),s("li",[a._v("子线程的ContextClassLoader是AppClassLoader。")]),a._v(" "),s("li",[a._v("AppClassLoader加载不了父线程当中已经加载的SpeakTest.class内容。")])]),a._v(" "),s("p",[a._v("我们修改一下代码，在子线程开头处加上这么一句内容。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("Thread.currentThread().setContextClassLoader(diskLoader1);\n")])])]),s("p",[a._v("结果如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1162),alt:""}})]),a._v(" "),s("p",[a._v("可以看到子线程的ContextClassLoader变成了DiskClassLoader。")]),a._v(" "),s("p",[a._v("继续改动代码：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("Thread.currentThread().setContextClassLoader(diskLoader);\n")])])]),s("p",[a._v("结果：")]),a._v(" "),s("p",[s("img",{attrs:{src:e(1163),alt:""}})]),a._v(" "),s("p",[a._v("可以看到DiskClassLoader1和DiskClassLoader分别加载了自己路径下的SpeakTest.class文件，并且它们的类名是一样的com.frank.test.SpeakTest，但是执行结果不一样，因为它们的实际内容不一样。")]),a._v(" "),s("h2",{attrs:{id:"context-classloader的运用时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#context-classloader的运用时机"}},[a._v("#")]),a._v(" "),s("strong",[a._v("Context ClassLoader的运用时机")])]),a._v(" "),s("p",[a._v("其实这个我也不是很清楚，我的主业是Android，研究ClassLoader也是为了更好的研究Android。网上的答案说是适应那些Web服务框架软件如Tomcat等。主要为了加载不同的APP，因为加载器不一样，同一份class文件加载后生成的类是不相等的。如果有同学想多了解更多的细节，请自行查阅相关资料。")]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" "),s("strong",[a._v("总结")])]),a._v(" "),s("ul",[s("li",[a._v("ClassLoader用来加载class文件的。")]),a._v(" "),s("li",[a._v("系统内置的ClassLoader通过双亲委托来加载指定路径下的class和资源。")]),a._v(" "),s("li",[a._v("可以自定义ClassLoader一般覆盖findClass()方法。")]),a._v(" "),s("li",[a._v("ContextClassLoader与线程相关，可以获取和设置，可以绕过双亲委托的机制。")])]),a._v(" "),s("p",[s("strong",[a._v("下一步")])]),a._v(" "),s("ul",[s("li",[a._v("你可以研究ClassLoader在Web容器内的应用了，如Tomcat。")]),a._v(" "),s("li",[a._v("可以尝试以这个为基础，继续学习Android中的ClassLoader机制。")])])])}),[],!1,null,null,null);s.default=n.exports}}]);