(window.webpackJsonp=window.webpackJsonp||[]).push([[1198],{2314:function(_,t,v){"use strict";v.r(t);var n=v(0),o=Object(n.a)({},(function(){var _=this,t=_._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"解答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解答"}},[_._v("#")]),_._v(" 解答")]),_._v(" "),t("p",[_._v("MySQL有两种死锁处理方式：")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("等待，直到超时（innodb_lock_wait_timeout=50s设置锁等待的时间，前提已经检测到锁的产生）。")])]),_._v(" "),t("li",[t("p",[_._v("发起死锁检测，主动回滚一条事务，让其他事务继续执行，回滚代价最小的那一个事务（innodb_deadlock_detect=on）。")])])]),_._v(" "),t("p",[_._v("由于性能原因，一般都是使用"),t("strong",[_._v("死锁检测")]),_._v("来进行处理死锁。")]),_._v(" "),t("p",[_._v("死锁检测的原理是构建一个以"),t("strong",[_._v("事务为顶点、锁为边")]),_._v("的有向图，判断有向图是否存在环，存在即有死锁。")]),_._v(" "),t("p",[_._v("检测到死锁之后，"),t("strong",[_._v("选择插入、更新或者删除的行数最少的事务回滚")]),_._v("，")]),_._v(" "),t("p",[_._v("基于 "),t("code",[_._v("INFORMATION_SCHEMA.INNODB_TRX")]),_._v(" 表中的 "),t("code",[_._v("trx_weight")]),_._v(" 字段来判断。")])])}),[],!1,null,null,null);t.default=o.exports}}]);