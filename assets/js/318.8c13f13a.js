(window.webpackJsonp=window.webpackJsonp||[]).push([[318],{2308:function(a,t,s){"use strict";s.r(t);var e=s(0),n=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"解答"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解答"}},[a._v("#")]),a._v(" 解答")]),a._v(" "),t("h3",{attrs:{id:"一、什么是spring三级缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是spring三级缓存"}},[a._v("#")]),a._v(" 一、什么是Spring三级缓存")]),a._v(" "),t("p",[t("img",{attrs:{src:s(980),alt:""}})]),a._v(" "),t("p",[a._v("第一级缓存：也叫单例池，存放已经经历了完整生命周期的Bean对象。")]),a._v(" "),t("p",[a._v("第二级缓存：存放早期暴露出来的Bean对象，实例化以后，就把对象放到这个Map中。（Bean可能只经过实例化，属性还未填充）。")]),a._v(" "),t("p",[a._v("第三级缓存：存放早期暴露的Bean的工厂。")]),a._v(" "),t("p",[a._v("注：")]),a._v(" "),t("p",[a._v("只有单例的bean会通过三级缓存提前暴露来解决循环依赖的问题，而非单例的bean，每次从容器中获取都是一个新的对象，都会重新创建，所以非单例的bean是没有缓存的，不会将其放到三级缓存中。")]),a._v(" "),t("p",[a._v("为了解决第二级缓存中AOP生成新对象的问题，Spring就提前AOP，比如在加载b的流程中，如果发送了循环依赖，b依赖了a，就要对a执行AOP，提前获取增强以后的a对象，这样b对象依赖的a对象就是增强以后的a了。")]),a._v(" "),t("p",[a._v("二三级缓存就是为了解决循环依赖，且之所以是二三级缓存而不是二级缓存，主要是可以解决循环依赖对象需要提前被aop代理，以及如果没有循环依赖，早期的bean也不会真正暴露，不用提前执行代理过程，也不用重复执行代理过程。")]),a._v(" "),t("h3",{attrs:{id:"二、对象在三级缓存中的创建流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、对象在三级缓存中的创建流程"}},[a._v("#")]),a._v(" 二、对象在三级缓存中的创建流程")]),a._v(" "),t("p",[a._v("A依赖B，B依赖A")]),a._v(" "),t("p",[a._v("1、A创建过程中需要B，于是先将A放到三级缓存，去实例化B。")]),a._v(" "),t("p",[a._v("2、B实例化的过程中发现需要A，于是B先查一级缓存寻找A，如果没有，再查二级缓存，如果还没有，再查三级缓存，找到了A，然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A。")]),a._v(" "),t("p",[a._v("3、B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中的状态）。然后回来接着创建A，此时B已经创建结束，可以直接从一级缓存里面拿到B，去完成A的创建，并将A放到一级缓存。")])])}),[],!1,null,null,null);t.default=n.exports},980:function(a,t,s){a.exports=s.p+"assets/img/cache.2e918460.png"}}]);